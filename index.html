<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>বাংলায় সি প্রোগ্রামিং</title>
	<meta name="description" content="">
	<meta name="keywords" content="">
	<link rel="stylesheet" href="css/jquery.mobile-1.4.5.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/highlightjs.css">
    

	<script src="js/jquery-1.11.3.min.js"></script>	
	<script src="js/jquery.mobile-1.4.5.js"></script>
	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>


 
 <div data-role="page" id="chome">
	<div data-role="header">	
		<h1>বাংলায় সি প্রোগ্রামিং</h1>
	</div>
	<div role="main" class="ui-content">
	
	
	<h3>অধ্যায় ১ - মৌলিক ধারনা</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#intro">ভূমিকা</a></li>	
		<li><a href="#why">কেন প্রোগ্রামিং?</a></li>	
		<li><a href="#c3456">প্রথম সি প্রোগ্রাম </a></li>	
		<li><a href="#c3457">সি প্রোগ্রামিং - ডেটা টাইপ এবং ভ্যারিয়েবল </a></li>
		<li><a href="#c3458">লাইব্রেরী ফাংশন </a></li>		
	</ul>
	
	<h3>অধ্যায় ২ - অপারেটর</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3459">Assignment operator </a></li>	
		<li><a href="#c3460">গাণিতিক অপারেটর </a></li>		    
		<li><a href="#c3461">ইউনারী অপারেটর </a></li>		    
		<li><a href="#c3462">লজিক্যাল অপারেটর </a></li>		    
		<li><a href="#c3463">কন্ডিশনাল অপারেটর </a></li>		
	</ul>
	
	<h3>অধ্যায় ৩ - ইনপুট আউটপুট</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
	    <li><a href="#c3464"> getchar & putchar </a></li>		    
		<li><a href="#c3465">scanf & printf </a></li>	
	</ul>
	
	<h3>অধ্যায় ৪ - কন্ট্রোল স্টেটম্যান্ট</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
				    
		    <li><a href="#c3466">প্রাথমিক ধারনা </a></li>		    
		    <li><a href="#c3467">সি প্রোগ্রামিংঃ if - else </a></li>		    
		    <li><a href="#c3468">while </a></li>		    
		    <li><a href="#c3469">সি প্রোগ্রামিংঃ do - while </a></li>		    
		    <li><a href="#c3470">সি প্রোগ্রামিংঃ for-লুপ </a></li>		    
		    <li><a href="#c3471">switch case </a></li>		
	</ul>
	
	<h3>অধ্যায় ৫ - ফাংশন</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3472">সি তে ফাংশন </a></li>		
	</ul>
	
	<h3>অধ্যায় ৬ - অ্যারে</h3>	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3473">C Array - অ্যারে </a></li>	
	</ul>
	
	<h3>অধ্যায় ৭ - পয়েন্টার</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3474">সি প্রোগ্রামিংঃ পয়েন্টার </a></li>
	</ul>	
	
	<h3>অধ্যায় ৮ - স্ট্রাকচার</h3>
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3475">সি প্রোগ্রামিংঃ স্ট্রাকচার - struct </a></li>	
	</ul>
	
	<h3>অধ্যায় ৯ - ফাইল অপারেশন</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
		<li><a href="#c3476">ফাইল অপারেশন </a></li>	
	</ul>
	
	<h3>অধ্যায় ১০ - পরিশিষ্ট</h3>
	
	<ul data-role="listview"  data-inset="true" data-theme="d">  
	    <li><a href="#c497">সি পোগ্রামিং - Strings / স্ট্রিং </a></li>		    
		<li><a href="#c499">ফ্লো চার্ট / Flow Chart  / প্রবাহ চিত্র </a></li>		    
		<li><a href="#c2578">C/সি প্রোগ্রামিং এ ডাইনামিক মেমরি এলোকেশন </a></li>		    
		<li><a href="#c2594">লিঙ্কড লিস্ট / Linked list সম্পর্কে ধারণা এবং সি প্রোগ্রামিং এ ইমপ্লিমেন্টেশন </a></li>	
		<li><a href="#c2204">রিকারশন/ Recursion , রিকার্সিভ অ্যালগরিদম, রিকার্সিভ ফাংশন ও সি প্রোগ্রামিং এ প্রয়োগ </a></li>
		<li><a href="#c1297">সি প্রোগ্রামিং দিয়ে কয়েকটা নাম্বার থেকে ম্যাক্সিমাম ও মিনিমাম বের করা। </a></li>			
	</ul>	
 
        
   	</div>
</div><!-- /page -->  


 
 
 <div data-role="page" id="intro">

	<div data-role="header">
	
	
	<h1>বাংলায় সি প্রোগ্রামিং</h1>
		
	</div>

	<div role="main" class="ui-content">

	<p> 
 বাংলায় সি প্রোগ্রামিং থেকে কিভাবে প্রোগ্রামিং করতে হয়, কিভাবে নিজে একটা প্রোগ্রাম লিখব পাশা পাশি একটা সফটওয়ার বা প্রোগ্রাম লিখতে কি কি লাগবে, এসব সম্পর্কে জানা যাবে। আমরা  যত গুলো অটোমেটিক মেশিন দেখি, সব গুলোই এক বা একের অধিক প্রোগ্রাম দিয়ে চলে। আর প্রোগ্রামটা লেখা হয় প্রোগ্রামিং ল্যাঙ্গুয়েজ দিয়ে। প্রোগ্রামিং জানলে যে শুধু কম্পিউটারের জন্যই সফটওয়ার তৈরি করা যাবে এমন না, সব কিছুর জন্যই প্রোগ্রাম বানানো যাবে। ছোট্ট একটা ক্যালকুলেটর হতে শুরু করে রোবোট বা এয়ারক্রাফট পর্যন্ত সব কিছুর প্রোগ্রাম।
</br> </br>
অনেক গুলো Programming Language রয়েছে শেখার জন্য। এ গুলোর মধ্যে জনপ্রিয় একটা হচ্ছে এই C Programming। ডেনিস রিচি (জন্ম সেপ্টেম্বর ৯, ১৯৪১ – মৃত্যু অক্টোবর ৮, ২০১১) এর ডেভেলপ করা এই সি ল্যাঙ্গুয়েজ থেকে নতুন অনেক গুলো ল্যাঙ্গুয়েজই তৈরি হয়েছে পরবর্তিতে। এ জন্য এই একটি ল্যাঙ্গুয়েজ ভালো করে শিখলে পরবর্তিতে অনেক গুলো ল্যাঙ্গুয়েজে সহজেই কোড লেখা যায়।
</br> </br>
কম্পিউটারকে ইন্সট্রাকশন দেওয়ার প্রক্রিয়া হচ্ছে প্রোগ্রামিং।  ইন্সট্রাকশন গুলো কিছু নির্দিষ্ট নিয়ম মেনে লিখতে হয়। যে নিয়ম গুলো মেনে প্রোগ্রাম লিখতে হয়, তা হচ্ছে প্রোগ্রামিং ল্যাঙ্গুয়েজ। সি শিখতে শিখতে আমাদের অনেক কিছুই শেখা হয়ে যাবে। একসময় আমরা সফটওয়ার, ওয়েব সাইট বা মোবাইল অ্যাপ, হোম অটোমেশন ইত্যাদির জন্য সফটওয়ার তৈরি করতে পারব। আর তা পারব আজ যদি আমরা শেখা শুরু করি। শেখা খুবি সহজ। যা যা লাগবে, তা হচ্ছে একটা কম্পিউটার, ইন্টারনেট আর কিছু না। বাকি গুলো ইন্টারনেট থেকেই শিখে নেওয়া যাবে। প্রোগ্রাম লেখার জন্য দরকার হচ্ছে একটা টেক্সট এডিটর বা আইডিই। তা সম্পর্কে বিস্তারিত জানা  প্রথম সি প্রোগ্রাম লেখাটিতে।
</br> </br>
একটা প্রোগ্রামিং ল্যাঙ্গুয়েজের কয়েকটি গুরুত্ত্বপূর্ণ টপিক্স হচ্ছে অপারেটর, স্ট্রিং এবং কারেকটার, কন্ট্রোল ফ্লো, লুপিং, ফাংশান, অ্যারে ইত্যাদি। এ অল্প কয়েকটি টপিক্স সব গুলো ল্যাঙ্গুয়েজ এর ভিত্তি। একটা ল্যাঙ্গুয়েজ এর গুলো ভালো করে জানা থাকলে বাকি ল্যাঙ্গুয়েজ গুলোর জন্যও জানা সহজ হয়ে যায়। এখানে দরকারী সব গুলো টপিক্সই সহজে লেখার চেষ্টা করেছি।
</br> </br>
বইটি লিখছি আমি জাকির হোসাইন। আমার ওয়েব সাইটেও এই বইটি পড়া যাবে। ঠিকানাঃ www.jakir.me/c
</br> </br>
যে কোন পরামর্শের জন্য ফেসবুকে আমার সাথে যোগাযোগ করা যাবে। ঠিকানাঃ www.facebook.com/jakir007
</p>
	
	</div>
</div><!-- /page -->

 <div data-role="page" id="why">

	<div data-role="header">
	
	
	<h1>কেন প্রোগ্রামিং?</h1>
		
	</div>

	<div role="main" class="ui-content">

<p> 	 
আচ্ছা, কেমন হত যদি না কম্পিউটার থাকত? যদি না ইন্টারনেট থাকত? যদি না ফেসবুক থাকত? আর যদি গুগল না থাকত তাহলে কি হতো? কিভাবে আমরা আমাদের এসাইনমেন্ট গুলো খুজে বের করতাম?
</br> </br>
গেমস, কম্পিউটার সফটওয়ার, মোবাইল এপলিকেশন, ওয়েব পেইজ যাই হোক না কেন সব জাগায় প্রোগ্রামিং। এটা তো কম্পিউটার বা কম্পিউটার রিলেটেড। অন্য কিছুর দিকে যদি তাকিয়ে দেখি, গাড়ি, এরোপ্লেন, মহাকাশ যান, মেডিকেল ডায়াগনসিস মেশিন, মাইক্রোওয়েব ওভেন, লিফট, গড়ি, ক্যালকুলেটর সহ সকল ইলেক্ট্রনিক্স যন্ত্রতেই প্রোগ্রামিং এর ব্যবহার রয়েছে।
</br> </br>
মানুষ নিজেদের ভাষা ব্যবহার করে একজন আরেক জনের সাথে যোগাযোগ করার জন্য। মেশিনের সাথে মানুষের যোগাযোগ করার জন্য ও একটা ভাষা দরকার, সে ভাষা হচ্ছে প্রোগ্রামিং। মেশিনের সাথে যোগাযোগ, এক্সাইটিং না?
 
প্রোগ্রামিং জানাটা এক্সাটিং থেকেও আরো বেশি কিছু।
</br> </br>
বুঝাই যাচ্ছে প্রোগ্রামিং কত গুরুত্ব পূর্ন। এক এক জাগায় এক এক ধরনের কাজ কর্ম করতে হয়। কাজ করার পদ্ধতি ভিন্ন, তাই প্রোগ্রাম গুলো ও ভিন্ন। আবার এই ভিন্ন ভিন্ন প্রোগ্রাম তৈরি করার জন্য রয়েছে অনেক গুলো প্রোগ্রামিং ল্যাঙ্গুয়েজ। এখানে একটূ ক্লিক করে দেখলেই হবে কত গুলো প্রোগ্রামিং ল্যাঙ্গুয়েজ রয়েছে। এগুলোর মধ্যে পাইথন অনেক সহজ একটা ল্যাঙ্গুয়েজ।
</br> </br>
প্রোগ্রামিং কতটা পাওয়ারফুল তা আমাদের কল্পনার ও বাহিরে। যে প্রোগ্রামিং জানবে, সে নতুন একটা পৃথিবী তৈরি করে ফেলতে পারবে। তৈরি করা যাবে নতুন একটা ভার্চুয়াল মহাবিশ্ব।
</br> </br>
প্রোগ্রামিং করে নিজের একটা ভার্চুয়াল অনুলিপি তৈরি করে ফেলা যাবে। Trancedence মুভি টা দেখেছ? না দেখে থাকলে বলব দেখে নিতে একটি বার। ঐ মুভিটার মত নিজের একটা অনুলিপি তৈরি করা সম্ভব। ভার্চুয়াল ভাবেই নিজের জ্ঞান অর্জন বাড়িয়ে নেওয়া সম্ভব। নতুন অর্জিত জ্ঞান কাজে লাগিয়ে অসাধারণ কিছু করে ফেলা সম্ভব। অসম্ভব কিছু না এই প্রোগ্রামিং এর দুনিয়াতে…
</br> </br>
কি করা সম্ভব তার একটা দিকই বললাম। আরো হাজারটি দিক রয়েছে। কি কি ইতিমধ্যে সম্ভব হয়েছে, তা তো আমরা দেখতেই পাচ্ছি। তারপর ও আমি কিছু বলার চেষ্টা করি।
</br> </br>
এই ফেসবুকে বসে পড়ি, এটা প্রোগ্রামিং দিয়েই তৈরি। এক একটা স্ট্যাটাস, ছবি ইত্যাদি আমাদের দেখানোর পেছনে অনেক গুলো কোড কাজ করছে। আমরা কোন ছবির উপর কতক্ষণ মাউস / আঙ্গুল রেখেছি, তা ট্র্যাক করা হচ্ছে। আর তা ট্র্যাক করে আমাদের সম্পর্কে জেনে নিচ্ছে ফেসবুক। আর আমাদের সম্পর্কে জেনে নিয়ে আমাদের কিসে কিসে আগ্রহ, সে সব রিলেটেড এড দেখাছে ডান কোনায়। মোবাইলের নিউজ ফিডে। …
</br> </br>
এক একটা মহামারি ভাইরাস আসলে আমাদের সবার ঘুম হারাম করে দেয়। কখন যে আমি আক্রান্ত হই। বিজ্ঞানীরা তখন ব্যস্ত থাকে ঐ ভাইরাস সম্পর্কে জানতে। ঐ ভাইরাসের জিন সিকোয়েন্স বের করে। তৈরি করে প্রতিষেধক। টিকা… এই প্রসেস গুলো আগে অনেক কঠিন ছিল, সময় অনেক বেশি লাগতো। কয়েক যুগ ও লেগে যেতো। কম্পিউটার আর প্রোগ্রামিং এর কল্যাণে অনেক সহজেই অনেক কম সময়ের মধ্যে একটা ভাইরাস সম্পর্কে জেনে নেওয়া যায়, তৈরি করা যায় প্রতিষেধক। আগের তুলনায় মহামারী ভাইরাসে তাই আস্তে আস্তে মৃত্যু হার কমে এসেছে…
</br> </br>
প্রোগ্রামিং মানুষের চিন্তা শক্তি বাড়িয়ে দেয়। চিন্তা করা মানে হচ্ছে নতুন কিছু করা। আমাদের পাওয়ারফুল যে একটা মস্তিষ্ক রয়েছে তার সঠিক ব্যবহার করা। যারা প্রোগ্রামিং জানে, আর যারা প্রোগ্রামিং জানে না তাদের চিন্তা করার পদ্ধতি ভিন্ন। প্রোগ্রামিং আমরা কিভাবে চিন্তা করি, তাই পরিবর্তন করে দেয়।
</br> </br>
সবাই নিজের ক্যারিয়ার নিয়ে একটু আধটু টেনশনে থাকে। প্রোগ্রামিং জানলে ক্যারিয়ার সম্পর্কে আর চিন্তা করতে হয় না। এমনকি সাধারণ অন্যান্য চাকরি করার জন্য দরকার সার্টিফিকেট। আর প্রোগ্রামিং জানাটাই হচ্ছে একটি সার্টিফিকেট। লাইভ সার্টিফিকেট। হাজার হাজার জব পড়ে আছে যে প্রোগ্রামিং জানে, তার জন্য।
</br> </br>
এক সময় সারাদিন বসে বসে গেমস খেলতাম। তখন খুব আপসুস করে চিন্তা করতাম, কেন সবাই গেমস খেলে না, এমন সারাদিন অন্য কাজ করে। গেমস খেলায় এত মজা। চিন্তা করলাম, মানুষ মারা যাওয়ার পর কি গেম খেলার সুযোগ পায়? আমি কি গেমস খেলার সুযোগ পাবো?
</br> </br>
এর কিছুদিন পর মাথায় উকি দিল, কিভাবে গেমস গুলো তৈরি হয়। তারপর শুনতে পেলাম প্রোগ্রামিং এর কথা। প্রোগ্রামিং করেই গেমস গুলো তৈরি হয়। এক্সাইটেড হয়ে গেলাম। প্রোগ্রামিং শিখতে হবে। আমাকে গেমস তৈরি করা জানতে হবে। এখন তোমার ও যদি একই ধরনের ইচ্ছে থাকে, গেমস তৈরি করা। তাহলে শুরু করে দিতে পারো। বা তোমার রোবট নিয়ে কাজ করার ইচ্ছে আছে? মাইক্রোসফট উইন্ডজের মত অপারেটিং সিস্টেম তৈরি করার ইচ্ছে আছে? ইচ্ছে আছে কি ফেসবুক বা গুগল থেকে বড় সড় ওয়েব সাইট তৈরি করার? তাহলে শুরুটা কিন্তু প্রোগ্রামিং দিয়েই শুরু করতে হবে।


	</p> 
	</div>
</div><!-- /page -->
  
<div data-role="page" id="c733">

	<div data-role="header">	
	
		<h1>প্রোগ্রামিং এ Array ও এর ব্যবহার।</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>একটা প্রোগ্রামের চিন্তা করি, যেটায় ইউজার থেকে দুইটা নাম্বার নিয়ে যোগ করে তা রিটার্ন / প্রিন্ট করবে বা কনসোলে দেখাবে।</p>
<p>সহজেই আপনি প্রোগ্রামটা লিখে পেলতে পারবেন তাই না? দুটি ভ্যারিয়েবল নিলাম, তারপর তা যোগ করে প্রিন্ট করলাম। শেষ।<br />
যেমনঃ</p>
<xmp>	  

#include<stdio.h>
int main()
{
	int x, y;
	printf("Enter First Number:\n");
	scanf("%d", &x);
	printf("Enter Second Number:\n");
	scanf("%d", &y);
	printf("Addition is %d", (x+y));
	return 0;
}
 
 
</xmp>	  


<p>আচ্ছা, যদি তিনটি সংখ্যা যোগ করতে বলে তখন কি করবেন? তিনটি ভ্যারিয়বল নিয়ে তা যোগ করে প্রিন্ট করবেন তাই তো?<br />
আচ্ছা, যদি তিনশ বা তিনহাজার সংখ্যা নিয়ে কাজ করতে হয় তখন কি করবেন? এত গুলো ভ্যারিয়বল কিভাবে লিখবেন? লিখতে কত সময় লাগবে? আর প্রোগ্রামের সাইজ কত বড় হয়ে যাবে না? আরো অনেক গুলো প্রশ্ন জন্ম নিবে এমন সমস্যায়। যাই হোক, প্রোগ্রামিং আসছে মানুষের সমস্যা কমাতে J বাড়াতে নয়। তাই এর জন্য অনেক সহজ একটা সমাধান আছে। যার নাম Array, অনেক মজার একটা জিনিস।</p>
<p>এখন আমাকে যদি আপনি জিজ্ঞেস করেন Array কি? তাহলে আমি বলব কন্টেইনার। বাক্স। যেটার মধ্যে অনেক কিছু রাখা যায়। বাক্সটা কেমন হবে তা আমরা বলে দিতে পারি। বাক্সটায় কয়েকটা খোপ/প্রকোষ্ঠ থাকবে তা আমরা বলে দিতে পারি এবং বলে দেওয়ার পর তার মধ্যে সুন্দর মত কিছু ডাটা/তথ্য রাখতে পারি।<br />
যেমন আমরা ৩০০টি ভ্যারিয়বল নিয়ে কাজ করব, তখন ঐ কন্টেইনার বা বাক্সে ৩০০টি প্রকোষ্ঠ আমাদের জন্য তৈরি হবে। আর আমরা সুন্দর মত একটা একটা করে ভ্যারিয়বল রাখতে পারব বাক্সের মত দেখতে ঐ Array তে। নিছের ছবিটি দেখুনঃ</p>
<img class="aligncenter  wp-image-30114" title="one dimension array" alt="" src="images/one-dimension-array.jpg" width="629" height="250" />
<p>এটা একটা বাক্সের মত দেখায় না যার মধ্যে ৬টি প্রকোষ্ঠ রয়েছে?</p>
<p>Array কিছুটা এমন। আর এটা দেখতে একটা লাইনের মত তাই না? আর তাই এর নাম Linear Array বা One Dimensional Array.<br />
Array এর ভিতরে যা থাকে তাকে Array Elements বলে। এরেতে সব ধরনের ডাটা রাখা যায়, এমন Integer, Character, Floating Point Number, String ইত্যাদি। Array তে আরেকটা জিনিস আছে, যার নাম হচ্ছে Index. যা দিয়ে আমরা কোন প্রকোষ্ঠে কিছু রাখতে পারব বা কি রাখছি তা বের করতে পারব। প্রতিটা প্রকোষ্ঠের একটা ইনডেক্স থাকে। Array এর প্রথম Element এর Index হচ্ছে ০, দ্বিতীয় Element এর Index বা উপাদানের হচ্ছে ১ , তৃতীয় উপাদানের হচ্ছে ২ ইত্যাদি। এভাবে বাড়তে থাকবে। উপাদানের নাম্বারের থেকে এক কমই হচ্ছে ইনডেক্স নাম্বার। যেমন ষষ্ঠ উপাদানের ইনডেক্স হচ্ছে ০৫।</p>
<p>ইনডেক্স কি তা এখনি পরিষ্কার হয়ে যাবে। মনে করি আমরা Number নামে একটা Array নিয়েছি যার সাইজ হচ্ছে ৬, সাইজ বলতে এরেতে কয়েটা উপাদান থাকবে তা বুঝানো হচ্ছে।<br />
এরে হচ্ছে একটা ভ্যারিয়েবল, যাকিছু ধরে রাখতে পারে সাধারন গাণিতিক ভ্যারিয়েবলের মত। এখন আমরা যদি Number নামক Array তে কিছু রাখতে চাই, তাহলে বলে দিতে হবে কোন ঘরে/ইনডেক্সে রাখব।<br />
যেমন</p>
<p>Number[0] = 77; লিখলে Number Array এর প্রথম ইন্ডেক্সে 77 রেখে দিবে।<br />
Number[1] = 11; লিখলে Number Array এর দ্বিতীয় ইন্ডেক্সে 11 রেখে দিবে।</p>
<p>Number[2] = 54; লিখলে Number Array এর তৃতীয় ইন্ডেক্সে 54 রেখে দিবে।</p>
<p>এভাবে বাকি ইনডেক্সে অন্যান্য সংখ্যা আমরা রাখতে পারব।</p>
<p>আচ্ছা আমরা এখন একটা প্রোগ্রাম চিন্তা করি যেটা ইউজার থেকে ৬টা নাম্বার নিবে এবং পরে তা যোগ করে রেজাল্ট আমাদের দেখাবে। এটা সাধারন পদ্ধতিতে করতে গেলে আমাদের আগে ৬টা ভ্যারিয়েবল নিতে হত, তারপর সেগুলোকে যোগ করতে হত তারপর যোগফল দেখাতে হতো।</p>
<p>এখন আমরা কত সহজেই এ জিনিসটা করতে পারব মাত্র একটি ভ্যারিয়েবল নিয়েঃ</p>

<xmp>
#include <stdio.h>
int main()
{
	int Number[6];
	int i, result=0;
	for(i=0; i<6; i++){
		printf("Enter %d no Number:\n", i+1);
		scanf("%d", &Number[i]);
		result +=Number[i];
	}
	printf("Result is: %d", result);
	return 0;
}
</xmp>
<p>প্রোগ্রামটা আসলে একটা বাজে প্রোগ্রাম। শুধু মাত্র বুঝানোর জন্য এমন ভাবে লেখা হয়েছে। এখানে আমরা একটা Integer Array নিলাম যার Size হচ্ছে 6, অর্থাৎ আমরা এর মধ্যে শুধু মাত্র ৬টি ইলিমেন্ট রাখতে পারব।<br />
scanf(&#8220;%d&#8221;, &Number[i]); এটা দিয়ে আমরা i এর বর্তমার মান যত তত তম ঘরে ইনপুট নেওয়া মানটি রাখব। প্রথমে i এর মা ধরে নিয়েছি 0, তা Number[0] অর্থাৎ প্রথম ঘরে রানটাইমে আমাদের ইনপুট দেওয়া সংখ্যাটি রাখবে। আমরা যেহেতু লুপ চালিয়েছি এবং প্রতিবার i এর মান এক করে বাড়িয়ে দিয়েছি তাই পরের বার i এর মান হবে 1 এবং Number[1] বা Number Array এর দ্বিতীয় ঘরে রানটাইমে দ্বিতীয়বার ইনপুট দেওয়া আমাদের সংখ্যাটি রাখবে। এভাবে লুপটি ৬ বার ঘুরবে। আমরা বুদ্ধি করে প্রতিবার সংখ্যাটি result +=Number[i] এ লাইনের সাহায্যে ইনপুট নেওয়ার সময় আগের যোগফলের সাথে যোগ করে দিচ্ছি। পরে রেজাল্টি প্রিন্ট করলে আমরা সব গুলো সংখ্যার যোগ ফল পেয়ে যাবো। এখন ইচ্ছে করলে আমরা প্রোগ্রামটি একটু মডিফাই করে কি কি সংখ্যা আমরা ইনপুট দিয়েছি তা বেরও করতে পারব। শুধু মাত্র আরেকটি লুপ চালিয়ে Number Array এর উপাদান গুলো প্রিন্ট করলেই হবে।</p>
<xmp>
#include <stdio.h>
int main()
{
	int Number[6];
	int i, j, result=0;
	
	for( i=0; i<6; i++){
		printf("Enter %d no Number:\n", i+1);
		scanf("%d", &Number[i]);
		result +=Number[i];
	}
	
	printf("Result is %d and you entered: ", result);
	
	for( j=0; j<6; j++){
		printf("%d  ", Number[j]);
	}
	return 0;
}
</xmp>

<p>Array অনেক দরকারি জিনিস। অনেক বেশি ব্যবহার এটির।</p>
<p>Array কিন্তু Multi-Dimensional হতে পারে। উপরে আমরা যে উদাহরনটি দেখেছি তা ছিল One-Dimensional এর Dimension সংখ্যা দুই, তিন বা আরো বেশি হতে পারে। Two Dimensional array নিচের মত।</p>

<img  src="images/two-dimensionsl-array.jpg" />
<p> এটি একটি Two Dimensional Character Array যার উপাদান সংখ্যা ১২। মনে করি Array টির নাম Character এবং এটিকে লিখতে হবে Character[3][4]  এখানে প্রথমটা হচ্ছে row সংখ্যা, দ্বিতীয়টি হচ্ছে Column সংখ্যা। অর্থাৎ এখানে ৩টি রো রয়েছে এবং ৪টি কলাম রয়েছে, সর্বোমোট উপাদাম সংখ্যা হচ্ছে ১২।<br />
প্রথম উপাধান অর্থাৎ উপরের Character নামক Two Dimensional Array থেকেঃ</p>
<p>প্রথম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][0] এবং তা হচ্ছে A</p>
<p>দ্বিতীয় উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][1] এবং তা হচ্ছে B</p>
<p>তৃতীয় উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][2] এবং তা হচ্ছে C</p>
<p>চতুর্থ উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][3] এবং তা হচ্ছে D</p>
<p>পঞ্চম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][0] এবং তা হচ্ছে E<br />
ষষ্ঠ উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][1] এবং তা হচ্ছে F<br />
সপ্তম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][2] এবং তা হচ্ছে G<br />
এভাবে আমরা পরের উপাদান গুলোও পেতে পারি।</p>
<p>কোন কিছু রাখতে হলে এ ভাবে একই ধাপ অনুসরন করতে হবে।<br />
প্রথম ইনডেক্সে একটা Character রাখব, তার জন্য লিখতে হবে Character[0][0]<br />
আগেই বলেছি Array Index শূন্য থেকে শুরু হয়।<br />
দ্বিতীয় ইনডেক্সে একটা Character রাখার জন্য লিখতে হবে Character[0][1]<br />
এভাবে বাকি গুলো রাখতে হবে।</p>
<p> হয়তো প্রথম প্রথম একটু বিদঘুটে লাগতে পারে, দুই একবার ভালো করে পর্যবেক্ষন করলে অনেক সহজ মনে হবে। আর চিন্তা করার সময় যদি বাস্তব জীবনের সাথে মিলিয়ে চিন্তা করা যায় তাহলে আরো দ্রুত বুঝা যাবে।</p>
<p>উদাহরন হিসেবে উপরে আমি সি প্রোগ্রামিং ব্যবহার করেছি। এরের মূল ধারনা এবং ব্যবহার সকল প্রোগ্রামিং এ একই। শুধু মাত্র এরে ডিক্লেয়ার করার পদ্ধতি ভিন্ন।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c1124">

	<div data-role="header">	
	
		<h1>Conditional Operator (?:)  - সি প্রোগ্রামিং এ  আমার প্রিয় একটা অপারেটর।</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>if-else statement এর পরিবর্তে Conditional Operator (?:) ব্যবহার করে সহজেই দুইটি statement অথবা valu এর মধ্যে তুলনা করে একটি মান নির্বাচিত করা যায়। Conditional Operator সি প্রোগ্রামিং এ নিচের মত করে লেখা হয়ঃ</p>
<p>condition ? first_expression : second_expression;</p>
<p>এখানে condition  হচ্ছে যে কোন একটা শর্ত। যা সত্য হলে   first_expression নির্বাচিত হবে। আর কন্ডিশন ভুল হলে second_expression।<br />
নিচে ছোট্ট একটা প্রোগ্রাম। যা দিয়ে দুটি সংখ্যার মধ্যে বড়টা নির্বাচিত  করা হয়েছে।</p>
<xmp>

#include <stdio.h>
int main()
{
 int x, y , result;
 scanf("%d %d", &x , &y);
 result = (x>;=y) ? x : y ;
 printf("max is %d", result);
 return 0;
}

</xmp>
<p>একই প্রোগ্রাম, কন্ডিশন পরিবর্তন করে  দুটি সংখ্যার মধ্যে ছোটটা নির্বাচিত  করা হয়েছে।</p>
<xmp>

#include <stdio.h>

int main()
{
	 int x, y , result;
	 scanf("%d %d", &x , &y);
	 result = (x<=y) ? x : y ;
	 printf("min is %d", result);
	 return 0;
}

</xmp>
<p>যদিও একই কাজ if -else বা অন্য অনেক ভাবে করা যায়।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c369">

	<div data-role="header">
	
		<h1>প্রোগ্রামিং এ ফাংশান।</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>আপনি একজন বিখ্যাত ম্যাজিশিনা। ম্যাজিশিয়ান না হলেও ভবিশ্যতে হবেন কারন আপনি একজন প্রোগ্রামার। প্রোগ্রামাররা অনেক কিছুই করতে হয়, তারা ম্যাজিক ও জানতে হয়। প্রোগ্রামারদের ম্যাজিক কি জানেন?</p>
<p>ওহ!! আমি এখনো বলিই নি, জানবেন কিভাবে। প্রোগ্রামারদের ম্যাজিক হচ্ছে ফাংশান। এখন আবার আপনার মনে হতে পারে এটা আবার কি? তাই না। মনে করেন আপনি একটা ম্যাজিক শোতে গিয়েছেন। আপনি এখন একটা ম্যাজিক দেখাবেন যেখানে একটা ছেড়া সুতোকে ফু দিলে তা জোড়ালেগে যাবে। এমনই তো দেখেন তাই না? এই ফু টাই হচ্ছে ফাংশান।</p>
<p>তাহলে আমরা এটা কিভাবে লিখব প্রোগ্রামে তা দেখিঃ</p>
<p>সম্পুর্ন সুতো= ফু(ছেড়া সুতো);</p>
<p>অর্থাৎ যাকে ফু দিবেন তা ব্র্যাকেটে লিখতে হয় তাহলে ফু দেওয়ার ফলে কি হয় তা পাওয়া যায়।</p>
<p>এখন ফু শুধু মাত্র ছেড়া সুতো উপর কাজ করে। এখন যদি আপনি ছেড়া সুতোর পরিবর্তে অন্য কিছু যেমন একটা কাগজকে ফু দেন তা কিন্তু টাকাতে পরিনত হবে না। তার জন্য কিছু মন্ত্র পড়তে হবে। এখানে মন্ত্রটা হচ্ছে ফাংশান।</p>
<p>টাকা = ফু(কাগজ);</p>
<p>কাগজের উপর ফু দিলে তা টাকাতে পরিনত হচ্ছে তাই না?<br />
ফাংশানটা ও একই রকম। এই ফু বা মন্ত্র এর মত। এখন আপনাকে বুঝতে হয় কোথায় কি ব্যবহার করতে হবে। অনেক হাবি জাবি বকা হয়ে গেছে এখন দেখি কিভাবে তা আমরা কাজে লাগাবো।</p>
<p>আমরা দুটি সংখা যোগ করতে চাই।</p>
<p>তার জন্য আমাদের যোগ নামে একটা ফাংশান লাগবে।</p>
<p>যোগফল = যোগ(সংখ্যা১, সংখ্যা২);</p>
<p>এখন আপনি হয়তো আমাকে দেখে হাসতে পারেন এত ভেজাল করার কি দরকার। আমি তো এমনিতেই দুটি সংখ্যার মাজে + চিহ্ন দিয়ে যোগ ফল পেতে পারি, মাঝখানে ফাংশান নামক এ বস্তুটা নিয়ে আসার কি দরকার?<br />
আচ্ছা, এটা আমাদের বার বার যোগ করা থেকে বাঁচিয়ে দিব। শুধু মাত্র যোগ ফাংশানটাকে ডাকলেই আমাদের কাজ করে দিব।</p>
<p>আচ্ছা, ফাংশান কি তা আগে জানি। <strong>ফাংশান হচ্ছে পুনরায় ব্যবহার যোগ্য কোড ব্লক। যা একটি নির্দিষ্ট কাজ করতে পারে। ফাংশান ভালো ভাবে জানলেই প্রোগ্রামিং এর একটা বিশাল অংশ শেখা শেষ হয়ে যায়। তা জানলেই নিজের ইচ্ছে মত কোড লেখা যায়। সকল প্রোগ্রামিং ল্যাঙ্গুয়েজ এ ফাংশান লেখার ধরন প্রায় একই।  আমি সি প্রোগ্রামিং দিয়ে উদাহরন দিচ্ছি। </strong><br />
একটা ফাংশান নিচের মত করে লেখা হয়ঃ</p>
<xmp>
Function_Data_Type Function_Name (Parameters){
....
return value;
}
</xmp>
<ul>
<li>Function_Data_Type হচ্ছে ফাংশানটি কি ধরনের ডেটা রিটার্ন করবে তা। যেমন int, char, float, double ইত্যাদি।</li>
<li>ফাংশানের তো একটা নাম থাকতে হবে তাই না? যে নাম দিয়ে ফাংশানটিকে ডাকতে হবে।  Function_Name হচ্ছে ফাংশানের নাম।</li>
<li>Parameters হচ্ছে ফাংশান দিয়ে কি কি ডেটা পাস করবে।  এখানে এক বা একাদিক Parameter পাস করা যেতে পারে। কোন কোন ফাংশানে কোন Parameter নাও থাকতে পারে।  এটা নির্ভর করে কি ধরনের ফাংশান লিখা হচ্ছে তার উপর। একের অধিক Parameter থাকলে তাদেরকে কমা দিয়ে লিখতে হয়।</li>
<li>কাজ শেষে ফাংশানটি কি রিটার্ন করবে তাই return দিয়ে  পাস করা হয়।</li>
</ul>
<p>নিচের ছবিটি দেখি। এখানে যোগ করার একটি ফাংশান এবং এর ভিবিন্ন অংশ দেখানো হয়েছেঃ</p>
<img class="aligncenter  wp-image-1102" alt="function add" src="images/function-add.jpg" />
<p style="text-align: left;">আমরা ছোট্ট একটা প্রোগ্রাম লিখে ফেলিঃ</p>
<xmp>
#include <stdio.h>
int add(int a, int b){
	int sum = a+b;
	return sum;
}
int main()
{
	int x, y , result;
	scanf("%d", &x);
	scanf("%d", &y);
	result = add(x,y);
	printf("Result is: %d", result);
	 return 0;
}
</xmp>
<p>#include <stdio.h> এর পরই আমরা ফাংশানটি লিখছি। main ফাংশান এর আগে। ফাংশানটি কল কছি add(x,y) দিয়ে। যার মধ্যে দুটি প্যারামিটার পাস করেছি। একটা x আরেকটা y, যে গুলো আমরা scanf ফাংশান দিয়ে ইনপুট হিসেবে নিয়েছি। এর ফলে আমাদের প্রোগ্রামটি main থেকে বের হয়ে add ফাংশানের ভেতরে যাবে। গিয়ে কিছু কাজ কমপ্লিট করবে। এবং ফাংশানের ভেতরের কাজ সম্পুর্ন হলে আবার main এ ফিরে আসবে।<br />
এখন ফাংশানে কি করছে জানেন? int a, int b নামক যে ভ্যারিয়েবল লিখছি ফাংশানের argument এ, প্রথম প্যারামিটার মানে x assign হবে a তে। এবং দ্বিতীয়টা মানে y assign হবে b তে। তারপর ফাংশানটি sum নামক ইন্টিজার ভ্যারিয়েবলে a+b এর মান রাখবে। return sum দিয়ে ঐ sum টা রিটার্ন করবে। এবং আমাদের main প্রোগ্রামে ফিরে আসবে। আবার ফাংশানে রিটার্ন করা ভ্যালুটা result নামক ভ্যারিয়েবলে এসাইন করবে।<br />
ছোট্ট একটা যোগের জন্য আসলেই আমরা অনেক বেজাল করে ফেলছি। তবে এখন আমরা ফাংশান কি তা জানি, কিভাবে কাজ করে তাও জানি।</p>
<p>এবার আরো সহজ একটা ফাংশান লিখি।</p>
<xmp>
#include <stdio.h>
void callme(){
	printf("You call me form Main \n");
}
int main()
{
	callme();
	return 0;
}

 

</xmp>
<p>এখানে আমরা callme নামক একটা ফাংশান লিখছি, যা কিছুই রিটার্ন করবে না। এ জন্য ফাংশানের Data Type লিখছি void। আচ্ছা, main থেকে যখন আমরা ফাংশানটিকে কল করছি  callme(); দিয়ে তখন ফাংশানের ভেতর গিয়ে দেখে You call me form Main লেখাটি প্রিন্ট করতে। প্রোগ্রামটি তাই করল। এবং callme ফাংশান থেকে বের হয়ে আবার main এ আসল। তারপর দেখল আর কোন কাজ নেই। তাই কি করল? প্রোগ্রামটি শেষ করল।</p>
<p>আমরা আরেকটু কঠিন একটা ফাংশান লিখে ফেলতে পারি না?</p>
<p>আমি কঠিন বলছি তাই বলে মোটেও কঠিন হবে না। এবার আমরা দুটি সংখ্যার মধে বড় সংখ্যাটা বের করার ফাংশান লিখব। তখন কি হবে জানেন? আচ্ছা আগে কোডটি লিখে ফেলিঃ</p>
<xmp>
#include <stdio.h>
int max(int a, int b){
	int maximum = (a>;=b) ? a : b ;
	return maximum;
}
int main()
{
	int x, y , result;
	scanf("%d", &x);
	scanf("%d", &y);
	result = max(x,y);
	printf("max is: %d", result);
	 return 0;
}

</xmp>
<p>এখানে আমরা max নামে একটা ফাংশান লিখছি। বাকি অংশন আগের মতই। ফাংশানের ভেতর Conditional Operator (?:) ব্যবহার করছি। আগের বার আমরা দুটি সংখ্যা যোগ করছি ফাংশানের ভেতর। এবার দুটি সংখ্যার মধে বড় সংখ্যাটা ফাংশান রিটার্ন করছে। এবং পরে তা আমরা প্রিন্ট করছি।</p>
<p>আচ্ছা, ফাংশান লিখলেই যে রিটার্ন করতে হবে এমন না। ফাংশান কোন কিছু রিটার্ন নাও করতে পারেন। সে ধরনের ফাংশানের Function_Data_Type লিখতে হয় void. আরেকটা ছোট্ট প্রোগ্রাম লিখে ফেলি, কি বলেন?</p>
<xmp>
#include <stdio.h>
void max(int a, int b){
	int maximum = (a>;=b) ? a : b ;
	printf("max is: %d", maximum);
}
int main(){
	int x, y;
	scanf("%d", &x);
	scanf("%d", &y);
	max(x,y);
	return 0;
}
</xmp>
<p>এখানে কি করছি জানেন, আমরা ফাংশানটিকে কল করছি। ফাংশানের ভেতরই বড় ছোট নির্নয় করেছি। ফাংশানের ভেতরই প্রিন্ট করছি। তারপর ফাংশান থেকে বের হয়ে গেছি। মেইন প্রোগ্রামে এসে দেখি আর কোন কাজ বাকি নেই। তাই পোগ্রামটি শেষ হয়েছে।</p>
<p>Factorial কি তা তো আমরা জানি, তাই না? একটি পূর্ণসংখ্যা ও শূন্য থেকে বড় ও সংখ্যাটি থেকে ছোট সকল পূর্ণসংখ্যার গুনফল হচ্ছে ফ্যাক্টোরিয়াল। n পূর্ণসংখ্যা হয়, তাহলে n এর ফ্যাক্টোরিয়াল প্রকাশ করা হয় এভাবেঃ n! যেমন 5! এর মান হবে 120</p>

<img class="aligncenter size-full wp-image-1129" alt="five factorial" src="images/five-factorial.png" width="248" height="15" />
<p>একটা পূর্ণসংখ্যার Factorial বের করার একটি প্রোগ্রাম লিখিঃ</p>
<xmp> 
#include <stdio.h>
long int factorial(int n){
int i;
long int result =1;
if(n>;1){
for(i=2; i<=n; i++)
result = result*i;
}
return result ;
}
int main()
{
int a;
scanf("%d", &a);
printf("Factorial of n is : %d", factorial(a));
return 0;
}
</xmp>
<p>এখানে আমরা একটি ফাংশান লিখছি যা ফ্যাক্টোরিয়াল বের করতে পারে। প্যারামিটার হিসেবে আমাদের রয়েছে একটি argument. প্রোগ্রামটি রান করে এর পর http://en.wikipedia.org/wiki/Factorial এখানে গিয়ে ভিবিন্ন সংখ্যার ফ্যাক্টোরিয়াল এর সাথে মিলিয়ে দেখুন আমাদের প্রোগ্রাম কাজ করে কিনা ঠিক মত।<br />
বড় সংখ্যার জন্য প্রোগ্রামটি ঠিক মত কাজ করবে না। কেন করবে না? বের করার দ্বায়িত্ব আপনার </p>
<p>আচ্ছা, আমরা এতক্ষন যে ফাংশান গুলো লিখছি তা main এর আগে লিখছি। আমরা ইচ্ছে করলে main এর পরেও লিখতে পারি। তবে তার জন্য main ফাংশান এর আগে তাকে ডিক্লেয়ার করতে হবে। যাকে বলে Function Prototype.</p>
<xmp>
#include <stdio.h>
void checkprime(int num);
int main()
{
int a;
scanf("%d", &a);
checkprime(a);
return 0;
}
void checkprime(int num){
 int i,count=0;
 for(i=2;i<=num/2;i++){
 if(num%i==0){
 count++;
 break;
 }
 }
 if(count==0 && num!= 1)
 printf("%d is a prime number",num);
 else
 printf("%d is not a prime number",num);
}

</xmp>
<p>এখানে আমরা প্রাইম নাম্বার চেক করার একটা প্রোগ্রাম লিখছি। এর মধ্যে আমরা  checkprime নামক একটা ফাংশান লিখছি যা আমরা main এর পর লিখছি। checkprime নামক যে একটা ফাংশান রয়েছে আমাদের প্রোগ্রামের main এর পর তা আমাদের আগে জানিয়ে দিতে হবে। সে জন্যই Function Prototype. এ জন্য মেইন এর আগে আমাদের ফাংশান প্রোটোটাইপ লিখতে হয়। যেমন আমাদের ফাংশানের প্রোটোটাইপ হচ্ছেঃ void checkprime(int num);</p>
<p>অর্থাৎ Function Prototype লিখতে হবে এমনঃ</p>
<xmp>Function_Data_Type Function_Name (Parameters);</xmp>
<p>যদিও অনেক কম্পাইলারে Function Prototype লিখতে হয় না।</p>
<p>এই হলো ফাংশান। অনেক সহজ জিনিস, তাই না? আগেই ও বলছি একবার আবার বলি। প্রোগ্রামিং শেখার জন্য অল্প কয়েকটি জিনিস বুঝলেই হয়। ভ্যারিয়েবল, লুপ, ফাংশান আর এরে। এগুলো দিয়েই যে কোন প্রোগ্রাম লিখে ফেলা যায়। দরকার একটু প্র্যাকটিস। আশা করি তা নিয়মিত করবেন।</p>
<p>সবার জন্য শুভ কামনা। শুভ প্রোগ্রামিং।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c1297">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিং দিয়ে কয়েকটা নাম্বার থেকে ম্যাক্সিমাম ও মিনিমাম বের করা।</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>আমরা আজ সি তে একটি প্রোগ্রাম লিখব যা দিয়ে কয়েকটি ইনপুট নাম্বার থেকে সবচেয়ে বড় নাম্বারটি এবং সব চেয়ে ছোট নাম্বারটি আমাদের বের করে দিবে।</p>
<xmp>

#include <stdio.h>
int main()
{
int num = 5; // total number you want to take as input
int i=1;
 int max=0;
 int min =999;
 int input;
 for (i=1; i<=num; i++){
 printf("Enter input number %d: \n", i);
 scanf("%d", &input);
 if(input>;max)
 max= input;
 if(input<min)
 min=input;
 }
 printf(" Max is: %d Min is: %d\n", max, min);
return 0;
}

</xmp>

<p>int num = 5; এখানে আমরা ৫টি মান ইনপুট নিব। ইচ্ছে করলে একে বাড়ানো বা কমানো যাবে।</p>
<p>int i=1; আমরা একটি for লুপ লিখছি এ প্রগ্রামে, তার জন্যই এ ভ্যারিয়েবলটি।</p>
<p>int max=0; আমরা ধরে নিচ্ছি আমাদের ম্যাক্সিমাম মান হচ্ছে ০।</p>
<p>int min =999;  আমরা ধরে নিচ্ছি আমাদের মিনিমাম মান হচ্ছে একটি অনেক বড় নাম্বার [এখানে ৯৯৯]। একটি বড় সংখ্যা রেখেছি। পরে যেন ছোট একটা সংখ্যা আসলে তার সাথে তুলনা করা যায়। এখানে যদি আমরা ছোট একটা সংখ্যা রাখি, তাহলে প্রোগ্রামটি ভালো ফলাফল দিবে না। 999 এর পরিবর্তে আমরা অন্য যে কোন মানই দিতে পারি। তবে তা হতে হবে আমরা যে সংখ্যা গুলো ইনপুট হিসেবে দিব তাদের থেকে বড়।
</p>
<p>এর পর আমরা একটি ভ্যারিয়েবল নিয়েছি যার মধ্যে আমাদের ইনপুট নাম্বারটা রাখব।</p>
<p>আমরা for লুপ ৫ বার চালিয়েছি এর পর। একবার একটা নাম্বার ইনপুট হিসেবে নিয়েছি।</p>
<p>লুপের ভেতরেই আমরা if কন্ডিশন দিয়ে মান গুলো চেক করেছিঃ</p>
<p>if(input>;max)<br />
max= input;</p>
<p>মনে করি আমরা প্রথম বার ইনপুট দিয়েছি ৫, যদি input এর মান max থেকে বড় হয়, তাহলে max= input; হবে। অর্থাৎ এখন পর্যন্ত বড় মানটা max এর মধ্যে পাবো। অর্থাৎ  এখন max এর মধ্যে থাকবে ৫;</p>
<p>if(input<min)<br />
min=input;</p>
<p>যদি input এর মান min থেকে ছোট হয়, তাহলে min= input; হবে। অর্থাৎ এখন পর্যন্ত ছোট মানটা min এর মধ্যে পাবো। আমরা আগেই min এর মধ্যে একটি বড় মান রেখে দিয়েছি। এখন যদি আমাদের মানটা [৫] যদি বর্তমানে রাখা min থেকে ছোট হয়, তাহলে এখন min=input; হবে। অর্থাৎ  এটা দিয়ে এখন min এর মধ্যে থাকবে ৫;</p>
<p>আমরা যেহেতু একটি নাম্বারই ইনপুট দিয়েছে, তাই এটিই সর্বচ্ছ, এটিই সর্ব নিম্ন।</p>
<p>এর পরের বারে গেলে সব বুঝা যাবে।</p>
<p>মনে করি এর পরের নাম্বার হিসবে আমরা ইনপুট দিয়েছি ৮,<br />
তাহলে</p>
<p>if(input>;max)<br />
max= input;</p>
<p>দিয়ে চেক করবে এই 8 কি আগের max থেকে বড় না ছোট। যদি   input এর মান max থেকে বড় হয়, তাহলে max= input; হবে। অর্থাৎ এখন পর্যন্ত বড় মানটা max এর মধ্যে পাবো। আগে max এর ভেতর ছিল ৫, এখন দেখতে পাচ্ছি ৮, অর্থাৎ বড়। তাই এখন max এর মধ্যে থাকবে ৮;</p>
<p>এর পর</p>
<p>if(input<min)<br />
min=input;</p>
<p>দিয়ে চেক করবে এখনকার ইনপুট নাম্বারকি আগের min থেকে ছোট নাকি, যদি ছোট হয় তাহলে min এর মধ্যে এখনকার ইনপুট নাম্বারটি রাখবে। যেহেতু আমাদের ইনপুটটি min থেকে বড়, তাই এখানে আর কিছুই হবে না।</p>
<p>যদি আমরা 5 এর থেকে ছোট একটি নাম্বার ইনপুট হিসেবে নি, তাহলেই  আমাদের min এর মান পরিবর্তন হয়ে ঐ মানটা min এর মধ্যে রাখবে।</p>
<p>এভাবেই আমরা অনেক গুলো সংখ্যা থেকে ছোট এবং বড় মানটি বের করে নিতে পারি।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c1214">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিং এ পয়েন্টার [Pointer]</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>পয়েন্টার প্রোগ্রামিং এ দারুন একটি টুল। পয়েন্টার সম্পর্কে জানার আগে কিছু ব্যাসিক জিনিস জানা যাক, যেগুলো বুঝতে কাজে দিবে।</p>

<p>ভ্যারিয়েবল গুলো কিভাবে কম্পিউটার মেমরিতে/ র‍্যাম এ স্টোর হয়?</p>
<p>র‍্যাম এর এক একটি সেল এক একটি বাইট। আর প্রত্যেকটা বাইট এর একটি করে এড্রেস রয়েছে। আর প্রতিটা বাইটে ৮টি করে বিট রয়েছে।</p>

<img  src="images/memory-cell-in-ram.jpg"   />

<p>আমরা যখন বলি আমাদের র‍্যাম 8 Giga byte, তখন আমাদের কম্পিউটারের র‍্যামে মোট 8 000 000 000 bytes ডেটা স্টোর করা যাবে, এবং এদের প্রত্যেকের একটি করে এড্রেস রয়েছে। প্রথমটি ০ পরের টি 1, এর পরের টির এড্রেস 2 এভাবে বাড়তে থাকে।  যদিও কম্পিউটার এ এড্রেস গুলো রিপ্রেজেন্ট করে হেক্সাডেসিমেল নাম্বার সিস্টেমে।</p>
<p>আমরা যখন একটি ভ্যারিয়েবল ডিক্লেয়ার করি আমদের প্রোগ্রামে, এবং যখন আমরা প্রোগ্রামটি এক্সিকিউট/রান করি তখন কম্পিউটার ঐ ভ্যারিয়েবল এর জন্য কিছু মেমরি এলোকেট করে। কতবাইট মেমরি এলোকেট করবে, তা নির্বর করে ঐ ভ্যারিয়েবল এর ডেটা টাইপ এবং কম্পাইলার এর উপর।</p>
<p>সাধারনত কম্পাইলার গুলো একটা int এর জন্য 2 byte মেমরি এলোকেট করে। তেমনি একটি char ভ্যারিয়েবলের জন্য 1 byte মেমরি এলোকেট করে। floating-point নাম্বার এর জন্য 4 byte মেমরি এলোকেট করে।</p>
<p>যেমন যখন কম্পিউটার দেখে এমন একটি ডিক্লারেশন int a; তখন এটি বুঝতে পারে এটি একটি ইন্টিজার ভ্যারিয়েবল এবং এর জন্য ২ বাইট মেমরি এলোকেট করা দরকার। তখন র‍্যাম এর খালি যায়গা থেকে এটি এই ইন্টিজারের জন্য ২ বাইট মেমরি এলোকেট করে।</p>
<p>আমরা সহজেই একটি ভ্যারিয়েবলের মেমরি লোকেশন বের করতে পারি, নিচের প্রোগ্রামটি দেখা যাকঃ</p>
<xmp>

#include <stdio.h>
int main()
{
int a =5;
printf("Memory address of variable a is: %x",&a);
return 0;
}
</xmp>
<p>উপরের প্রোগ্রামটি রান করালে এমন কিছু দেখাবেঃ Memory address of variable a is: 2686732 । এক কম্পিউটারে এক এক মান দেখাবে। এবং একবার একে এক ভ্যালু দেখাবে।   কোন ভ্যারিয়েবল এর এর মেমরি এড্রেস জানার জন্য & [ampersend] ব্যবহার করা হয়। যাকে  address-of operator [&] ও বলা হয়।  যা দিয়ে আমরা অন্য একটি ভ্যারিয়েবল এর  এড্রেস বা মেমরি লোকেশন পেতে পারি।</p>
<p>যখন আমরা প্রোগ্রামটি রান করি, তখন কম্পিউটার র‍্যাম এর খালি যায়গা থেকে ভ্যারিয়েবল a এর জন্য ২ বাইট মেমরি এলোকেট করে। কম্পিউটার অটোমেটিকেলি তখন a এর জন্য 2686732 এবং 2686733 নং সেল এলোকেট করে রাখে। আর মেমরি এড্রেস জানার জন্য শুধু মাত্র শুরুর এড্রেস জানলেই হয়। আমরা যখন a এর মেমরি এড্রেস প্রিন্ট করেছি, তখন শুধু শুরুর এড্রেস 2686732 ই পেয়েছি। যদি ও a ভ্যারিয়েবল এর জন্য 2686732 এবং 2686733  মেমরি এলোকেট করা হয়েছে এবং এর মান 5 এই দুই সেলে স্টোর করে রাখা হয়েছে। এখন আমরা যদি a এর মান পরিবর্তন করে অন্য আরেকটা ভ্যালু রাখি, যেমন 8, তখন র‍্যামের 2686732 এবং 2686733 এ দুটো সেল এর মান ও পরিবর্তন হয়ে যাবে এবং এ দুটো সেলে 5 এর পরিবর্থে 8 স্টোর হবে। এবার পয়েন্টার কি জানা যাক।</p>
<p><strong>পয়েন্টার হচ্ছে একটা ভ্যারিয়েবল যার ভ্যালু হচ্ছে আরেকটি ভ্যারিয়েবল এর মেমরি লোকেশন।</strong> পয়েন্টার  একটা ডেটা, অ্যারে বা ভ্যারিয়েবল এর কম্পিউটার মেমরি লোকেশন  রিপ্রেজেন্ট করে বা পয়েন্ট করে। অন্যান্য ভ্যারিয়েবল এর মত  পয়েন্টার ভ্যারিয়েবল ব্যবহার করার আগে কম্পিউটার/ কম্পাইলারকে বলতে হবে এটা একটি পয়েন্টার ভ্যারিয়েবল। নিচের মত করে একটি পয়েন্টার ভ্যারিয়েবল ডিক্লেয়ার করে।</p>
<p>data_type *name;</p>
<p>যেমন integer পয়েন্টারের জন্যঃ  int *i;</p>
<p>asterisk [*] একটি ভ্যারিয়েবলের আগে ব্যবহার করে পয়েন্টার হিসেবে ডিক্লেয়ার করা হয়। যাকে indirection operator বা value-at-address operator বলা হয়। এখানে আরো কিছু ডেটা টাইপ এর পয়েন্টার ডিক্লারেশন এর উদাহরন দেওয়া হলোঃ</p>
<xmp>
int*ip;/* pointer to an integer */
double*dp;/* pointer to a double */
float*fp;/* pointer to a float */
char*ch /* pointer to a character */
</xmp>
<p>আমরা এখন দেখব কিভাবে পয়েন্টার ব্যবহার করতে হয় একটি প্রোগ্রামে।</p>
<xmp>

#include <stdio.h>
int main ()
{
int a = 5; /* variable declaration */
int *ip; /* pointer variable declaration */
ip = &a; /* store address of "a" in pointer variable*/
printf("Address of a variable: %x\n", &a );
/* address stored in pointer variable */
printf("Address stored in ip variable: %x\n", ip );
return 0;
}

</xmp>
<p>এখানে আমরা একটি ভ্যারিয়েবল a ডিক্লেয়ার করেছি। এরপর একটি পয়েন্টার ভ্যারিয়েবল ডিক্লেয়ার করেছি। তারপর পয়েন্টার ভ্যারিয়েবলে a এর মেমরি এড্রেস রেখেছি। তারপর & অপারেটর দিয়ে a ভ্যারিয়েবল এর এড্রেস প্রিন্ট করে দেখলাম। এবং পয়েন্টার ভ্যারিয়েবল এর ভ্যালু প্রিন্ট করে দেখলাম। উভয় এর মান ই একই।</p>
<p>আমরা ইচ্ছে করলে এখন ip  পয়েন্টার ভ্যারিয়েবল দিয়ে a এর মান বের করতে পারি।</p>
<xmp>

#include <stdio.h>
int main ()
{
int a = 5;
int *ip;
ip = &a;
/* access the value using the pointer */
printf("Value of *ip variable: %d\n", *ip );
return 0;
}

</xmp>
<p>আমরা যখন প্রগ্রামটি রান করব, তখন ip যে ভ্যারিয়েবলটির এড্রেস শো করবে, তার মান প্রিন্ট করবে। লক্ষকরি, যখন আমরা পয়েন্টার ভ্যারিয়েবল দিয়ে কোন ভ্যারিয়েবল এর এড্রেস বের করতে চাইবো, তখন শুধু পয়েন্টার ভ্যারিয়েবল লিখলেই হবে। কিন্তু যখন আমরা পয়েন্টার ভ্যারিয়েবল দিয়ে মূল ভ্যারিয়েবল এর ভ্যালু বের করতে চাইবো, তখন পয়েন্টার ভ্যারিয়েবল এর আগে <strong>*</strong> যোগ করতে হবে। যেমন প্রথম প্রোগ্রামে আমরা ip [পয়েন্টার ভ্যারিয়েবল] প্রিন্ট করায় আমরা এড্রেস পেয়েছি। এবং পরের প্রোগ্রামে ip এর আগে একটা * দিয়ে *ip প্রিন্ট করায় আমরা মূল ভ্যারিয়েবলের মান পেয়েছি।</p>


 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c2204">

	<div data-role="header">	
	
		<h1>রিকারশন/ Recursion , রিকার্সিভ অ্যালগরিদম, রিকার্সিভ ফাংশন ও সি প্রোগ্রামিং এ প্রয়োগ</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>কোন কিছু যদি নিজেকে নিজে পুনরায় ডাকে, করে তাই হচ্ছে <strong>রিকারশন/ Recursion।</strong> যেমন একটা ছবির মধ্যে ঐ ছবিটি, ঐ ছবিটির ভেতরে আবার ঐ ছবিটি&#8230; এ প্রসেসটা হচ্ছে রিকারশনের একটা উদারহণ।<br />
</br><br />
একটা খালি মাঠে গিয়ে নিজেকে নিজে ডাকলে বা একটা বিশাল হল রুমে নিজের নাম ধরে ডাকা ডাকি করলে রিকার্শন অনুভব করা যাবে।</p>
<p>নিচের ছবিটি দেখিঃ</p>

<img class="wp-image-2205" src="images/Screenshot_Recursion_via_vlc.png" />

<p>গুগলে Recursion লিখে সার্চ করে দেখুন। বার বার লেখা উঠবে Did you mean: Recursion। বানান ঠিক থাকার পর ও এটা দেখাবে। গুগল মজা করে একটা রিকারশন বসিয়ে দিয়েছে Recursion সার্চ টার্ম এর উপর।</p>
<p><strong>Recursive Algorithm</strong> হচ্ছে যে অ্যালগরিদম নিজেকে নিজে কল করে, তা। কম্পিউটার প্রোগ্রামিং এ  রিকারসিভ অ্যালগরিদম ব্যবহার করে কোন প্রোগ্রামে রিকারশন ব্যবহার করা হয়। বিভিন্ন প্রোগ্রামিং ল্যাঙ্গুয়েজে একটি ফাংশন নিজেকে কল করার মাধ্যমে রিকারশন এর প্রয়োগ করা হয়। আমরা রিকার্সিভ ফাংশন ব্যবহার করে দুই একটা রিকার্সিভ অ্যালগরিদম দেখব। আর প্রোগ্রামিং ল্যাঙ্গুয়েজ হিসেবে ব্যবহার করব সি।</p>

<p>রিকার্সিভ ফাংশন কি তা তো এখন সহজেই বলা যাচ্ছে তাই না? যে ফাংশন নিজেকে নিজে কল করে, তাই হচ্ছে রিকার্সিভ ফাংশন। 
<p>রিকারশনের সুবিধে হচ্ছে কোড সহজ করে, অনেক গুলো কোড লেখার পরিবর্তে কয়েক লাইনের কোড দিয়ে একটা সমস্যা সমাধান করা যায়।</p>
<p><strong><em>void f() {</em></strong><br />
<strong><em>   f() &#8230;</em></strong><br />
<strong><em>}</em></strong></p>
<p>এটা একটা রিকার্সিভ ফাংশন, কারণ ফাংশনটি নিজেকে নিজে কল করেছে। এটাকে বলে সরাসরি কল। আবার ফাংশন সরাসরি কল না করেও এমন একটা ফাংশনকে কল করতে পারে, যে ফাংশনটি প্রথম ফাংশনকে কল করে। নিচের উদারহণটি দেখিঃ</p>
<p><em><strong>void f() {</strong></em><br />
<em><strong>    g() &#8230;</strong></em><br />
<em><strong>}</strong></em></p>
<p><em><strong>void g() {</strong></em><br />
<em><strong>   f() &#8230;</strong></em><br />
<em><strong>}</strong></em></p>
<p>f ফাংশনটি g ফাংশনকে কল করেছে। আবার g ফাংশন f ফাংশনকে কল করেছে। এটাও রিকার্সিভ ফাংশন।</p>

<p>আমরা একটা রিকার্সিভ ফাংশন লিখি, যেটা ইউজার থেকে একটা নাম্বার নিবে, তারপর ঐ সংখ্যা থেকে এর পর ১ থেকে ঐ সংখ্যা পর্যন্ত সকল সংখ্যা প্রিন্ট করবে। এটা সিম্পল একটা প্রোগ্রাম। তবে আমরা এ প্রোগ্রামটি নতুন ভাবে লিখব। রিকারশন ব্যবহার করে। প্রোগ্রামটি যেহেতু সিম্পল, তাহলে আমরা একটু ভালো করে দেখলেই বুঝতে পারব। আর প্রোগ্রামটি কিভাবে কাজ করে, তা বুঝতে পারলেই আমরা রিকার্শন বুঝে ফেলব। এরপর আমরা কমপ্লেক্স সব প্রোগ্রাম রিকারশন ব্যবহার করে সহজেই লিখে ফেলতে পারব। আগে ফাংশনটি <strong>Pseudo code </strong><strong>[সুডো কোড]</strong> এ আগে লিখি, এরপর সি প্রোগ্রামিং এ ইমপ্লিমেন্টেশন দেখব।</p>

<p><strong>Pseudo code</strong> হচ্ছে একটা প্রোগ্রাম বা একটা অ্যালগরিদমের ধাপ গুলো সাধারণ মানুষের ব্যবহার উপযোগি করে লেখা কিছু কোড। এগুলো কোন প্রোগ্রামিং ল্যাঙ্গুয়েজ ব্যবহার করে লেখা হয় না। এমন ভাবে লেখা হয় যেন মানুষ বুঝতে পারে। নিচে printInt নামে একটি ফাংশনের সুডো কোড দেওয়া হলো, যা ১ থেকে ঐ সংখ্যা পর্যন্ত সকল সংখ্যা প্রিন্ট করবে।</p>


<table>
<tbody>
<tr>
<td width="623">printInt( k ) {<br />
if (k == 0) {<br />
return 0;<br />
}<br />
print(k );<br />
printInt( k - 1 );<br />
&nbsp;</p>
<p>}</td>
</tr>
</tbody>
</table>

<p>ফাংশনটি প্যারামিটার হিসেবে একটা ইন্টিজার নিবে। এরপর চেক করবে সংখ্যাটা কি ০? যদি শুন্য হয়, ঐখানেই ফাংশনের কাজ শেষ হবে। যদি ০ না হয় তাহলে ইন্টিজারটি প্রিন্ট করবে। এবং ঐ ইন্টিজার সংখ্যাটি থেকে ১ বিয়োগ করে আবার printInt কে কল করবে। মানে নিজেকে নিজে কল করবে।</p>

<p>এখন আমরা যদি printInt ফাংশনে 2 পাস করি, তাহলে ফাংশনটির তিনটে কপি তৈরি হবে। একটা হচ্ছে k এর মান 2 এর জন্য, একটা হচ্ছে k এর মান 1 এর জন্য। আর একটা হচ্ছে k এর মান ০ এর জন্য।</p>

<table>
<tbody>
<tr>
<td width="156"><strong>যখন k এর মান 2</strong><br />
printInt( int k ) {<br />
if (k == 0) {<br />
return 0;<br />
}<br />
print(k );<br />
printInt( k - 1 );<br />
}</p>
<p>প্রিন্ট করবে 2</td>
<td width="156"><strong>যখন k এর মান 1</strong><br />
printInt( int k ) {<br />
if (k == 0) {<br />
return 0;<br />
}<br />
print(k );<br />
printInt( k - 1 );<br />
}<br />
প্রিন্ট করবে 1</td>
<td width="156"><strong>যখন k এর মান 0</strong><br />
printInt( int k ) {<br />
if (k == 0) {<br />
return 0;<br />
}<br />
print(k );<br />
printInt( k - 1 );<br />
}<br />
k এর মান ০ হওয়ায় কিছুই প্রিন্ট করবে না।</td>
</tr>
</tbody>
</table>

<p>এভাবে এখন আমরা যদি printInt ফাংশনে 5 পাস করি, তাহলে ফাংশনটির পাঁচটি কপি তৈরি হবে। অর্থাৎ যে সংখ্যা পাস করব, তত সংখ্যক বার ফাংশনটির কপি তৈরি হবে। আর এভাবেই রিকারশন কাজ করে।</p>

<p>এবার সি প্রোগ্রামিং এ  ইমপ্লিমেন্টেশন দেখিঃ<br /> </p>
<xmp> 
#include <stdio.h>


void printInt( int k ) {
     if (k == 0) {
         return 0;
     }
    printf( "%d \n", k );
    printInt( k - 1 );


}

int main(){
    int i;
    printf("Enter a number: ");
    scanf("%d", &i );
    printInt(i);

    return 0;
}

</xmp>
<p>প্রোগ্রামটিতে প্রথমে আমরা আমাদের printInt ফাংশনটি লিখেছি। এর পর মেইন ফাংশনের ভেতর একটা ইন্টিজার ডিক্লেয়ার করেছি। তা ইউজার থেকে ইনপুট নিয়েছি। এরপর printInt ফাংশনে ইন্ট্রিজারটি পাস করেছি। আর printInt হচ্ছে রিকার্সিভ ফাংশন। যে নিজেকে নিজে কল করে আমাদের কাজ করে দিচ্ছে।</p>

<p>আরেকটা সিম্পল প্রোগ্রাম রিকারশন ব্যবহার করে লেখার চেষ্টা করি। যেমন একটা সংখ্যা ইউজার থেকে ইনপুট নিবে, তারপর ১ থেকে ঐ সংখ্যা পর্যন্ত সকল সংখ্যার যোগফল প্রিন্ট করবে। যখন ইনপুট হিসেবে 4 থাকবে তখন সাধারণ একটা প্রোগ্রাম যোগফল নির্নয় করবে নিচের মত করেঃ<br />
sum(4) = 1+2+3+4<br />
যখন ইনপুট হিসেবে থাকবে 5 তখনঃ<br />
sum(5) = 1+2+3+4+5<br />
যখন ইনপুট হিসেবে থাকবে 6 তখনঃ<br />
sum(6) = 1+2+3+4+5+6</p>
<p>যার মানে হচ্ছেঃ</p>
<table>
<tbody>
<tr>
<td width="623">sum(6) = sum(5) + 6 [sum(5)=(1+2+3+4+5)]<br />
sum(5) = sum(4) + 5 [sum(4)=(1+2+3+4)]<br />
sum(4) = sum(3) + 4 [sum(3)=(1+2+3)]<br />
sum(3) = sum(2) + 3 [sum(2)=(1+2)]<br />
sum(2) = sum(1) + 2 [sum(1)=(1)]<br />
sum(1) = sum(0) + 1 [sum(0)=(0)]<br />
sum(0) = 0
</td>
</tr>
</tbody>
</table>
<p>উপরের স্টেপ গুলো ৬টা সংখ্যার জন্য। এখন আমরা n তম সংখ্যার যোগফলের জন্য সহজ একটা ইকুয়েশন লিখে ফেলতে পারি, sum(n) = sum(n-1) + n.<br />
&nbsp;<br />
যখন ০ হবে, তখন প্রিন্ট করবে ০, আর যখন n হবে, তখন প্রিন্ট করবে sum(n) = sum(n-1) + n.</p>
<p>আর এটা সুডো কোডে লিখলেঃ</p>
<table>
<tbody>
<tr>
<td width="623">sum( int n ) {<br />
if( n == 0 ) return 0;<br />
else return n + sum( n-1 );<br />
}
</td>
</tr>
</tbody>
</table>
<p>সি পোগ্রামে এর প্রয়োগ করলেঃ<br />

<xmp> 
#include <stdio.h>

int sumFunc( int n ) {
    if( n == 0 )
        return 0;
    else
    return n + sumFunc( n-1 );
}

int main(){
    int n,sum;
    printf("Enter the value of n: ");
    scanf("%d",&n);
    sum = sumFunc(n);
    printf("Sum of n numbers: %d",sum);

    return 0;
}
</xmp>
<p>রিকার্শনের আরেকটা উদারহণ দেখি, এবার দেখব রিকার্শন ব্যবহার করে Factorialবের করার উপায়।<br />
&nbsp;<br />
একটা সংখ্যার <strong>Factorial</strong> হচ্ছে ১ থেকে ঐ সংখ্যা পর্যন্ত সব গুলো সংখ্যার গুণফল। একটা সংখ্যার ফ্যাক্টোরিয়াল এভাবে দেখানো হয়ঃ n! এখানে প্রথমেই ধরে নেওয়া হয় ০ এর Factorial হচ্ছে ১।</p>
<p>১ এর ফ্যাক্টোরিয়াল ১।<br />
দুই এর ফ্যাক্টোরিয়াল ১*২ =২।<br />
৩ এর ফ্যাক্টোরিয়াল হচ্ছে ১*২*৩ = ৬।<br />
৪ এর ফ্যাক্টোরিয়াল হচ্ছে ১*২*৩*৪ = ২৪।<br />
৫ এর ফ্যাক্টোরিয়ালঃ<br />
&nbsp;<br />
<img src="images/factorial-5.png" height="15"  /><br />
&nbsp;<br />
আমরা এভাবে লিখতে পারিঃ factorial(n) = (n * factorial(n-1)); আর যেহেতু factorial(0) = 1, আমরা factorial এর জন্য একটা রিকার্সিভ ফাংশনের সুডো কোড লিখে ফেলতে পারিঃ</p>
<table>
<tbody>
<tr>
<td width="623">factorial(n) {<br />
if (n == 0)<br />
return 1;<br />
else<br />
return (n * factorial(n-1));<br />
}<br />
&nbsp;</td>
</tr>
</tbody>
</table>
<p>factorial(0) = 1</p>
<p>তাহলে যদি আমরা factorial(3) এর মান বের করি, ফাংশনটি এভাবে কাজ করবেঃ</p>
<table>
<tbody>
<tr>
<td width="623">factorial(3) =<br />
3 * factorial(2)<br />
3 * 2 * factorial(1)<br />
3 * 2 * 1 * factorial(0)<br />
3 * 2 * 1 * 1<br />
= 6<br />
&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;<br /> 
সি প্রোগ্রামিং এ ইমপ্লিমেন্টেশনঃ<br /></p>
<xmp> 
#include <stdio.h>

int factorial(int n) {
   if (n == 0)
      return 1;
   else
      return (n * factorial(n-1));
}

int main(){
    int n,result;
    printf("Enter the value of n: ");
    scanf("%d",&n);
    result = factorial(n);
    printf("Factorial is : %d",result);

    return 0;
}
</xmp>

<p>এবার আপনি একটা সমস্যা রিকারশন ব্যবহার করে সলভ করতে চেষ্টা করুন। যেমন ইউজার থেকে একটা সংখ্যা ইনপুট নিবে, ধরি n। আর প্রোগ্রামটাকে করতে হবে কি, n তম Fibonacci সংখ্যাটা বের করতে হবে। </p>
 

 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3456">

	<div data-role="header">	
	
		<h1>প্রথম সি প্রোগ্রাম</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>প্রোগ্রামিং করার জন্য দরকার একটা কম্পিউটার আর একটা কম্পাইলার। দুইটার মধ্যেই কি সদৃশ্য তাই না? দুটাই ক দিয়ে শুরু এবং &#8220;ম্প&#8221; যুক্ত বর্ণ রয়েছে।<br />
আপনার একটা কম্পিউটার রয়েছে তা না হলে তো এ লেখাটা পড়তে পারতেন না, তাই না? এবার দরকার একটা কম্পাইলার। একটা সি কম্পাইলার। যে আমাদের কোড প্রোগ্রামিং এর কোড গুলোকে কম্পাইল করে দিবে।</p>
<p>কম্পাইলার কেন দরকার তা বলছি আগে। আমাদের আমরা যা লিখি কম্পিউটার তা পড়তে পারে না । কম্পিউটারের জন্য দরকার মেশিন ল্যাঙ্গুয়েজ। 
	আমাদের সি প্রোগ্রামিংকে মেশিন ল্যাঙ্গুয়েজে পরিবর্তন করে দেয় এই কম্পাইলার। 
<p>আমরা সি কোড লেখা ও কম্পাইল করার জন্য CodeBlocks IDE ব্যবহার করব । CodeBlocks ডাউনলোড করতে চাইলে এই লিঙ্ক এ গিয়ে ডাউনলোড করা যাবেঃ http://www.codeblocks.org
<p>তারপর ইন্সটল করুন। ওপেন করুন। তাহলে নিচের মত দেখতে পারেবন।</p>
<img class="wp-image-1208 alignnone" src="images/codeblocks.jpg" />
<p><strong>ইন্সটল হলে আপনি কোড লেখার জন্য প্রস্তুত।</strong></p>
<p><strong>এখান থেকে Create New Project এ ক্লি করুন।</strong></p>
<p><img src="images/create-new-c++-project.png" alt="" /></p>
<p><strong> <span style="line-height: 1.3em;">এখান থেকে Console Application সিলেক্ট করে Go তে ক্লি করুন।</span></strong></p>
<p><a href="images/select-programming.png" rel="lightbox[3456]" title="select programming"><img class="aligncenter" src="images/select-programming.png" alt="select programming" width="521" height="436" /></a></p>
<p>এবার C সিলেক্ট করে Next এ ক্লিক করুন। Project Title বক্স এ আপনার প্রজেক্ট এর নাম দিন। যেমন hello. Folder to create project in বক্স থেকে আপনার প্রজেক্টটি কোন ফোল্ডারে সেভ করতে চান তা সিলেক্ট করুন। Next এ ক্লি করুন। এবার Finish এ ক্লি করুন।</p>
<p>এবার ডান পাশে আপনার workspace দেখতে পাবেন। ঐখানে আপনার প্রোজেক্ট গুলো দেখাবে। hello এর + চিহ্নতে ক্লিক করুন। তারপর Source এর + চিহ্নতে ক্লিক করুন এবং main.c এর উপর ক্লিক করুন। CodeBlocks একটা  সিম্পল একটা কোড  টেম্পলেট  তৈরি করে প্রতি প্রজেক্টের জন্য, তা দেখাবে। যার মধ্যে লেখা থাকবেঃ</p>
<xmp>
#include<stdio.h>
int main()
{
    printf("Hello world!");
    return 0;
}
</xmp>
<p>আমাদের কোডটি কম্পাইল এবং রান করতে হবে তার জন্য ফাইল মেনু থেকে Build এ ক্লিক করুন এবং Build and Run এ ক্লিক করুন। তাহলে আপনার সি প্রোগ্রামটি কম্পাইল হবে এবং রান হবে। এবং নিচের মত আউটপুট দিবেঃ</p>
<p><a href="images/c++-program.jpg" rel="lightbox[3456]" title="c++ program"><img class="aligncenter" src="images/c++-program.jpg" alt="c++ program" width="684" height="353" /></a></p>
<p>আপনি যদি উপরের প্রোগ্রামটি রান করাতে পারেন, তাহলে আপনাকে অভিনন্দন এবং স্বাগতম প্রোগ্রামিং এর মজার দুনিয়াতে। না করতে পারলে মন খারাপ করার দরকার নেই। আবার একটু চেষ্টা করুন প্রথম থেকে। তাহলেই হবে।</p>
<p>উপরের কোডে আমরা কি লিখছি তা এবার একটু ব্যাখ্যা করা যাক।</p>
<p>আমাদের প্রোগ্রামের প্রথম লাইন হচ্ছে  #include<stdio.h> । include মানে হচ্ছে কোন কিছু যুক্ত করা। stdio এর পূর্ণরূপ হচ্ছে standard input output. stdio.h এর .h দিয়ে বুঝানো হয় এটা একটা header ফাইল। আর পুরো লাইন দিয়ে বুঝানো হয় যে standard input output কে যুক্ত কর।  standard input output সম্পর্কে আরেকটু পরে বলব।</p>
<p>এর পরের লাইন হচ্ছে  int main(), এটিকে বলা হয় মেইন ফাংশন। আমরা যখন প্রোগ্রামটি রান করাবো তখন এ মেইন ফাংশন থেকে কাজ করা শুরু করবে।  তাই সব প্রোগ্রামে একটি (এবং কেবল একটি) মেইন ফাংশন থাকতে হয়। মেইন ফাংশনের শুরুতে দ্বিতীয় বন্ধনী দিয়ে শুরু করতে হয়।  মেইন ফাংশন শেষও করতে হয় একটি দ্বিতীয় বন্ধনী দিয়ে।<br />
মেইন ফাংশন এর দ্বিতীয় বন্ধনী এর ভেতর প্রথম লাইন লিখছি আমরা printf(&#8220;Hello world!&#8221;);<br />
এখানে printf() হচ্ছে একটি ফাংশন। printf এর মানে হচ্ছে <b>print f</b>ormatted। এটি একটি লাইব্রেরী ফাংশন যাকে স্ট্যান্ডার্ড আউপুট ফাংশন বলে।   printf()    এর কাজ হচ্ছে কনসোলে/স্ক্রিনে কিছু প্রিন্ট করা। ডবল কোটেশন চিহ্নের ভেতরে আমরা যা লিখব তা-ই স্ক্রিনে সে প্রিন্ট করবে। আমরা প্রথমেই যে একটি লাইন লিখছি #include<stdio.h> । printf() ফাংশনটি কিভাবে কোন কিছু প্রিন্ট করে তা লেখা রয়েছে এই stdio.h ফাইলে।</p>
<p>এর পর আমরা আরেকটি লাইন লিখছি return 0; আমরা বলছি যে main হচ্ছে একটা ফাংশন। প্রত্যক ফাংশন এর একটা return মান থাকতে হয়। যা ফাংশন এর কাজ শেষে কিছু একটা রিটার্ন করে। return 0 মানে শূন্য রিটার্ন করা। এ সম্পর্কে পরে আরো বিস্তারিত জানা যাবে যখন আমরা
ফাংশন নিয়ে পড়ব।</p>
<p>printf(&#8220;Hello world!&#8221;); বা return 0; এ গুলোকে বলে স্টেটমেন্ট (Statement)। প্রতিটি স্টেটমেন্টের শেষে একটি করে সেমিকোলন  (;) দিতে হয়। আমরা যদি সেমিকোলন না দিয়ে থাকি তাহলে কম্পাইলারে ভুল দেখাবে এবং প্রোগ্রামটি রান হবে না। প্রোগ্রামিং এর শুরুর দিকে অনেকেই সেমিকোলন দিতে ভুলে যায়,তখন কম্পাইল এরর (compile error) দেখায়, পরে কোথায় ভুল হয়েছে খুজে বের করার চেষ্টা করে। একটু খেয়াল করে কোড লিখলে এসব ছোটখাটো ভুল গুলো সহজেই এড়ানো যায়।</p>
<p>এবার এ প্রোগ্রামটি নিজে নিজে লিখতে চেষ্টা করুন। Hello world! এর পরিবর্তে আপনার নাম বা ইচ্ছে মত কিছু দিয়ে রান করার চেষ্টা করুন।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3457">
	<div data-role="header">	
		<h1>সি প্রোগ্রামিং - ডেটা টাইপ এবং ভ্যারিয়েবল</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>এর আগের প্রোগ্রামে আমরা মাত্র এক লাইন এর একটা আউটপুট দেখিয়েছি। যা শুধু মাত্র প্রোগ্রামিং শুরু করার জন্যই যথেষ্ট ছিল। বাস্তবে আমাদের জটিল কিছু প্রোগ্রাম লিখতে হবে। যার জন্য দরকার আমাদের ভ্যারিয়েবল এর ধারনা।</p>
<p>ভ্যারিয়েবল হচ্ছে একটি নাম, যা দিয়ে কম্পিউটারের মেমরিতে কোন ডেটা রাখা হয়। এ ডেটা হতে পারে নিউম্যারিক (যে কোন সংখ্যা) অথবা একটি character মান। এ ভ্যারিয়েবল এর মধ্যে কি ধরনের ডেটা রাখব আমরা তাই হচ্ছে ডেটা টাইপ। ভ্যারিয়েবল সম্পর্কে আমরা পরে আবার জানব। এবার একটু এ ডেটা টাইফ সম্পর্কে জানি।</p>
<p>সি প্রোগ্রামিং এ অনেক প্রকারের ডাটা টাইপ আছে। তার মধ্য প্রধান চারটি হচ্ছেঃ</p>
<ul>
<li><strong>int data type</strong></li>
<li><strong>char data type</strong></li>
<li><strong>float data type</strong></li>
<li><strong>double data type</strong></li>
</ul>

<h2>int data type</h2>
<p>int data type বলতে integer quantity(অবিভাজ্য সংখা যেমনঃ ১, ২, ৩ ইত্যাদি) বুঝায়। এর সাইজ ২ বাইট বা ১৬ বিট(১বাইট=৮বিট)এবং রেঞ্জঃ -৩২৭৬৮ থেকে +৩২৭৬৭ পর্যন্ত।  কিছু কিছু কম্পাইলারে int ডেটার জন্য ৪ বাইট মেমরি দেয়। অর্থাৎ একটা int ডেটা টাইপের জন্য সর্বোচ্চ ৪ বাইট ডেটা রাখা যাবে। যার রেঞ্জ হচ্ছে  -2,147,483,648 থেকে 2,147,483,647 এ রেঞ্জ এর মানে হচ্ছে এর থেকে বড় মানের সংখ্যা যদি আমরা ব্যবহার করি তাহলে কম্পাইলার সঠিক মান দিবে না। এ সাইজ এবং রেঞ্জ কম্পাইলার ভেদে ভিন্ন হতে পারে।<br />
int data type এর উদাহরন হিসেবে আমরা একটা প্রোগ্রাম দেখতে পারি। একটি আয়াতাকার  জমির দৈর্ঘ্য এবং প্রস্থ জানলে আমরা তার ক্ষেত্রফল বের করতে পারি। তাই না? মনে করে নিচ্ছি দৈর্ঘ্য ৫ একক এবং প্রস্থ ৮ একক। আমরা এর ক্ষেত্রফল হবে ৫*৮ = ৪০ একক। প্রোগ্রামে আমরা কিভাবে তা বের করতে পারি? নিচের প্রোগ্রামটি দেখি।</p>
<xmp>

#include <stdio.h>

int main()
{
 int volume;
 int length = 5;
 int width = 8;
 volume = length * width;
 printf("%f", volume);
 return 0;
}

</xmp>
<p>প্রোগ্রামটি রান করলে আমরা আউটপুট দেখতে পাবো 40</p>
<p>এটা অবশ্যই আমাদের প্রথম প্রোগ্রাম থেকে দেখতে অনেক জটিল। এবং কিছুটা বড়। তবে অবশ্যই অনেক সহজ। কিছুক্ষন আগে আমরা ভ্যারিয়বল নামে একটা বস্তুর নাম শুনছি যা কোন কিছু স্টোর বা সেভ করে রাখে কম্পিউটার মেমরিতে।<br />
আমাদের হিসেব করা জমির ক্ষেত্রফল বের করে ও তো কম্পিউটার মেমরিতে রাখতে হবে। কম্পিউটার মেমরিতে রাখার জন্য আমাদের দরকার একটা ভ্যারিয়েবল। ক্ষেত্রফল রাখার জন্য আমাদের ভ্যারিয়েবল এর নাম দিয়েছি volume, কিন্তু volume এ আমরা কি ধরনের ডেটা রাখব তা কম্পিউটারকে জানতে হবে না? আমরা যেহেতু একটা ক্ষেত্রফল রাখব এবং তা হচ্ছে একটা সংখ্যা।</p>
<p>কিছুক্ষন আগে int নামে আমরা একটা ডেটা টাইপ সম্পর্কে জেনেছি। যা দিয়ে কম্পিউটারে <strong>Integer</strong>/ পূর্ণসংখ্যা কম্পিউটারে সংরক্ষন করা যায়। তাই আমরা int ব্যবহার করেছি। আর এর সব টুকু লিখছি একটা লাইনের মধ্যে<strong> int volume;</strong> যাকে বলা হয় ভ্যারিয়েবল ডিক্লারেশন। অর্থাৎ একটা ভ্যারিয়েবল ব্যবহার করার আগে একে ডিক্লেয়ার করতে হয়। ডিক্লেয়ারেশন শেষ আমরা একটা সেমি কোলন দিয়েছি। একটি ভেরিয়েবল ডিক্লেয়ারেশন শেষে তা শেষ করার জন্য একটা সেমিকোলন ব্যবহার করতে হয়।  অর্থাৎ একটি ভ্যারিয়েবল ডিক্লেয়ার করতে হয় নিচের মত করেঃ</p>
<xmp>

data_type variable_name;

</xmp>
<p>কম্পিউটারকে তো আমাদের জানাতে হবে যে আমাদের জমির দৈর্ঘ্য এবং প্রস্থ কত, তাই না?  এর জন্য আমরা আরো দুটি ভ্যারিয়েবল নিয়েছি  length এবং width নামে। এ দুটি আবার int volume; থেকে একটু ভিন্ন। আমরা এ দুটি ভ্যারিয়েবল ডিক্লেয়ার করার সাথে সাথে একটি মান সেট করে দিয়েছি। যাকে বলে ভ্যালু এসাইন করা। মান সহ ভ্যারিয়েবল ডিক্লেয়ার করার নিয়ম হচ্ছেঃ</p>
<xmp>

data_type variable_name = value;

</xmp>
<p>এর পর বর্তীতে আমরা লিখছি volume = length * width; এর মানে হচ্ছে length ভ্যারিয়েবল এর মান এবং width ভ্যারিয়েবল এর মান গুন করে volume এ রাখা।</p>
<p>এর পরবর্তী লাইন এর সাথে আমরা কিছুটা পরিচিত।  printf(&#8220;%d&#8221;, volume); যা হচ্ছে printf() ফাংশন।<br />
printf() ফাংশন এর কাজ হচ্ছে কোন কিছু প্রিন্ট করা। একটা লেখা প্রিন্ট করার জন্য printf() এর ভেতর ডাবল কোটেশন এর মধ্যে কিছু লিখলেই তা প্রিন্ট করে দেয়, তা আমরা এর আগেই জেনে এসেছি।</p>
<p>কিন্তু এবার আমরা একটা ইন্টিজার ভ্যালু প্রিন্ট করব এবং একট ভ্যারিয়েবল এর থেকে। এর জন্য কিছু নিয়ম আমাদের ফলো করতে হবে। একটি ইন্টিজার প্রিন্ট করার জন্য printf() এর ভেতর ডাবল কোটেশন দিয়ে লিখতে হয় %d, এটিকে বলে placeholder। প্রত্যেকটি ডেটা টাইপের জন্য আলাধা আলাধা placeholders  রয়েছে। %d মানে হচ্ছে display integer। ডাবল কোটেশনের পর আমরা একটি কমা দিয়েছি। এর পর লিখছি আমাদের ইন্টিজার ভ্যারিয়েবলটি। যা আমাদের জমির ক্ষেত্রফল প্রিন্ট করে দিয়েছে।<br />
এ কাজটা তো আমরা মুখেই করতে পারতাম তাই না? ভালো হতো যদি প্রোগ্রামটা রান হওয়ার পর দৈর্ঘ্য এবং প্রস্থ নেওয়া যেত। তাহলে আমরা যে কোন জমির ক্ষেত্রফল বের করতে পারতাম। আমরা এমন কিছুই শিখব। তার আগে আরো কিছু ব্যাসিক ধারনা নিয়ে নি।</p>


<h2>প্লেসহোল্ডার / Placeholder</h2>
<p>কিছুক্ষণ আগে আমরা placeholder নামে একটা শব্দ শুনেছি। প্রত্যেকটা ডেটা টাইপের জন্য আলাদা আলাদা প্লেসহোল্ডার রয়েছে। নিচে ভিন্ন ভিন্ন ডেটা টাইপ ও তাদের প্লেসহোল্ডার গুলো দেওয়া হলোঃ</p>
<table>
<tbody>
<tr>
<td width="312"> ডেটা টাইপ</td>
<td width="312"> প্লেসহোল্ডার</td>
</tr>
<tr>
<td width="312"> int</td>
<td width="312"> %d</td>
</tr>
<tr>
<td width="312"> char</td>
<td width="312"> %c</td>
</tr>
<tr>
<td width="312"> float</td>
<td width="312"> %f</td>
</tr>
<tr>
<td width="312"> double</td>
<td width="312"> %lf</td>
</tr>
</tbody>
</table>
<h2>character data type</h2>
<p>এবার আমরা character data type সম্পর্কে একটু জানতে পারি।</p>
<p>char data type বলতে single character( একটি বর্ন যেমন a, b, z, A, N ইত্যাদি) বুঝায়। এর সাইজ ১ বাইট বা ৮ বিট।বিট (১বাইট=৮বিট) এবং রেঞ্জঃ -১২৮ থেকে +১২৭ পর্যন্ত। আমাদের কীবোর্ডের প্রত্যেকটি চিহ্নই এক একটা  character। কারেকটার ভ্যারিয়েবল ডিক্লেয়ার করার নিয়ম হচ্ছেঃ</p>
<p><strong>char variable_name;</strong></p>
<p>character ভ্যারিয়েবলে মাত্র একটি কারেকটার / লেটার / বর্ণ সংরক্ষন করা যায়। নিচের প্রোগ্রাম দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
char ch = 'A';
printf("%c", ch);
return 0;
}

</xmp>
<p>এখানে ch নামে একটা কারেকটার ভ্যারিয়েবল নিয়েছি। এরপর তা প্রিন্ট করেছি। ভ্যারিয়েবলের মধ্যে কোন কারেকটার এসাইন করার জন্য তা সিঙ্গেল কোটেশনের মধ্যে রাখতে হয়। এভাবে &#8216;A&#8217; ।</p>

<h2><strong>float data type: </strong></h2>
<p>integer ডেটা টাইফে শুধু মাত্র পূর্ণ সংখ্যা গুলো সংরক্ষন করা যায়। আপনি একটা integer ভ্যারিয়েবলে একটি দশমিক মান যেমনঃ ৮.৯ বা ইচ্ছে মত কিছু রাখুন। এর পর ঐ ভ্যারিয়েবলটি প্রিন্ট করুন। কি দেখলেন? দশমিকের পরের অংশ নেই তাই না? নিচের প্রোগ্রামটা আপনি রান করিয়ে দেখতে পারেনঃ</p>
<xmp>

#include <stdio.h>

int main()
{
 int n = 8.9;
 printf("%f", n);
 return 0;
}

</xmp>
<p>এটা শুধু আমাদের 8 দেখাবে। যদিও আমরা ভ্যারিয়েবলটির মধ্যে রেখেছি 8.9 । এর কারন হচ্ছে int শুধু মাত্র পূর্ণ সংখ্যা গুলোকে কম্পিউটার মেমরিতে সংরক্ষিত করতে পারে। দশমিক মান কম্পিউটারে রাখার জন্য আমাদের দরকার আরেকটি ডেটা টাইফ, যার নাম float ।</p>
<p>float data type বলতে floating point number( দশমিক সংখা যেমনঃ ১০.৫, ১.৮, ৫.৬ ইত্যাদি) বুঝায়। floating point ডেটা টাইফ দশমিকের পর ৬ ঘর পর্যন্ত নির্ভুল মান দিতে পারে। উপরের প্রোগ্রামটার ভ্যারিয়েবল n এর Data Type পরিবর্তন করে float দিয়ে রান করিয়ে দেখুনঃ</p>

<xmp>

#include <stdio.h>

int main()
{
 float n = 8.9;
 printf("%d", n);
 return 0;
}

</xmp>
<p>এটি এবার সঠিক মান দিবে।</p>
<p>বৃত্তের ক্ষেত্রফলের জন্য দরকার এর ব্যাসার্ধের মান। ধরে নিচ্ছি একটি বৃত্তের ব্যাসার্ধ 7.6 একক। আমরা এর ক্ষেত্রফল বের করার একটা প্রোগ্রাম লিখে ফেলিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
 float radius = 7.6;
 float area = (radius*radius * 3.1416);
 printf("%f", area);
 return 0;
}

</xmp>
<p>আমরা radius নামে একটা floting point ভ্যারিয়েবল নিয়েছি। এর মধ্যে বৃত্তের ব্যাসার্ধ রেখেছি। area নামে আরেকটি ভ্যারিয়েবল নিয়েছি যার মধ্যে ক্ষেত্রফল বের করে রেখেছি।</p>
<p>আমরা যানি বৃত্তের ক্ষেত্রফল হচ্ছে ব্যাসার্ধ*ব্যাসার্ধ্য * পাই এর মান। তাই লিখছি এবং মানটি প্রিন্ট করেছি।</p>
<p>এর আগে integer এর উদাহরনে printf ফাংশনে placeholder হিসেবে ব্যবহার করেছি %d, floating point এর জন্য placeholder হচ্ছে %f । বাকিটা তো সহজ তাই না?</p>
<p>আমরা জেনেছি যে floating point দশমিকের পর  ৬ ঘর পর্যন্ত নির্ভুল মান দিতে পারে। এর থেকে বেশি ঘর পর্যন্ত নির্ভুল মান পেতে হলে আমাদের আরেকটি ডেটা টাইফ ব্যবহার করতে হবে যার নাম হচ্ছে double ।</p>

<h2><strong>double data type</strong></h2>
<p>double data type বলতে Double precision floating point number বুঝায়।এটা float data type এর মতোই তবে সাইজ বিশাল। এর সাইজ ৮ বাইট বা ৬৪ বিট। এবং এটি দশমিকের পর ১৫ ঘর পর্যন্ত নির্ভুল মান দিতে পারে।</p>

<p>আমরা জানি বৃত্তের পরিধি ও ব্যাসের অনুপাতকে পাই/ Pi [Π]  দিয়ে প্রকাশ করা হয়। এটি একটি অমূলদ সংখ্যা। এটিকে দশমিক আকারে সম্পূর্ণ প্রকাশ করা সম্ভব নয়। দশমিকের পর অসীম সংখ্যা রয়েছে, এ জন্য। আমরা যদি float দিয়ে এর মান বের করার চেষ্টা করি, আমরা পাব দশমিকের পর ৬ ঘর পর্যন্ত। কিন্তু double দিয়ে যদি এর মান বের করি, তাহলে পাব দশমিকের পর ১৫ ঘর পর্যন্ত নির্ভুল মান। double এর মান প্রিন্ট বা আউটপুট পাবার জন্য প্লেসহোল্ডার হিসেবে আমাদের lf ব্যবহার করতে হবে। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
double pi = 3.14159265358979323846;
printf("%lf", pi);
return 0;
}

</xmp>
<p>এখন যদিও কম্পাইল করে রান করার পর দশমিকের পর ৬ ঘরই দেখাবে। কিন্তু আমরা বলছি ১৫ ঘর পর্যন্ত নির্ভুল মান দিবে। ঠিকই বলেছি। এখন কম্পাইলারকে বলে দিতে হবে কত দশমিকের পর কত ঘর প্রিন্ট করবে। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
double pi = 3.14159265358979323846;
printf("%.9lf", pi);
return 0;
}

</xmp>
<p>এখানে আমরা প্লেসহোল্ডারে লিখেছি .9lf । প্লেসহোল্ডারে দশমিক দিয়ে কত ঘর পর্যন্ত প্রিন্ট করবে, তা বলে দিলে তত ঘর পর্যন্তই প্রিন্ট করবে। উপরের প্রোগ্রামটি এখন পাই এর মান দশমিকের পর ৯ ঘর পর্যন্ত প্রিন্ট করবে।</p>
<p>মাথায় দুষ্টু বুদ্ধি খেলা করে তাই না?  .9lf এর জায়গায়  .50lf দিলে দশমিকের পর ৫০ ঘর প্রিন্ট করবে, তাই তো? হ্যা, ঠিকই  .50lf লিখলে ঠিকই দশমিকের পর ৫০ ঘর পর্যন্ত প্রিন্ট করবে। তবে তা আমরা যে রেজাল্ট চাচ্ছি তা পাবো না। ভুল কিছু পাবো। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
double pi = 3.14159265358979323846;
printf("%.20f", pi);
return 0;
}

</xmp>
<p>এখানে আমরা পাই এর মান দশমিকের পর ২০ঘর পর্যন্ত দিয়েছি। এরপর আমরা চাচ্ছি ২০ ঘর পর্যন্তই মান পেতে। তাই প্লেসহোল্ডারে .20f দিয়ে বলে দিয়েছি যেন দশমিকের পর ২০ ঘর পর্যন্ত প্রিন্ট করে। কিন্তু দশমিকের পর ১৫ ঘর পর্যন্ত ঠিক মানই প্রিন্ট করেছে। এরপর কত গুলো শূন্য দিয়ে পূরণ করে দিয়েছে। কারণ dobule ডেটা টাইপ দশমিকের পর ১৫ ঘর পর্যন্ত মান ঠিক মত মনে রাখতে পারে।</p>

<h2>ডেটা টাইপ এবং তাদের রেঞ্জঃ</h2>
<p>শুরুতেআমরা রেঞ্জ নিয়ে কিছু পড়েছি, হয়তো ঠিক মত বুঝতে পারি নি। কিন্তু এবার বুঝেই ছাড়ব। আমরা বলেছি int data type এর সাইজ হচ্ছে ২ বাইট। আমরা জানি এক বাইট সমান ৮ বিট। তাহলে দুই বাইট সমান ১৬ বিট। আর এই ১৬ বিটের মানে হচ্ছে কম্পিউটার (2<sup>16 </sup>-1) =  (65536 -1) = 65535 পর্যন্ত নির্ভুল ভাবে সেভ করতে পারবে। মানে আমরা সুন্দর ভাবেই0-65535 পর্যন্ত যে কোন মান একটি ইন্টিজারে সেভ করতে পারব। এখন যদি আমরা এর থেকে বড় কোন মান যেমন। 65538 ইন্টিজার ডেটা টাইপে সেভ করি, কম্পাইলার ঠিক মত মান আমাদের আউটপুট দিতে পারবে না।</p>

<p>আমরা বলেছি যে কিছু কিছু কম্পাইলার ইন্টিজারের জন্য ৪ বাইট মেমরি বরাদ্ধ করে। ৪ বাইট মানে হচ্ছে ৪*৮ বিট। = ৩২ বিট। আর ৩২ বিট মানে আমরা (2<sup>32 </sup>-1) = (4294967296 -১) = 4294967295 পর্যন্ত নির্ভুল মান সেভ করতে পারব ইন্টিজার ডেটা টাইপ হিসেবে। এর থেকে বড় কোন মান যদি ইন্টিজার হিসেবে সেভ করতে চাই, তাহলে ঠিক মত আউটপুট পাবো না। যেটা পাবো সেটা দারুণ। দারুণ কেন বলছি। আগে 4294967295 এর থেকে বড় যে কোন একটা সংখ্যা ইন্টিজার ভ্যারিয়েবল হিসেবে প্রিন্ট করে দেখি। যেমন 6294967295</p>
<xmp>

#include <stdio.h>

int main()
{
 int n = 6294967295;
 printf("%d", n);
 return 0;
}

</xmp>
<p>কি আউটপুট পাচ্ছি? আমি পাচ্ছি 1999999999&#8230; যেটা পাওয়ার কথা সেটা পাই নি। কারণ ইন্টিজার ডেটাটাইপে যতটুকু ক্ষমতা তার থেকে বড় মান আমরা সেভ করার চেষ্টা করেছি, তাই।</p>
<p>4294967295 এর পরবর্তি সংখ্যা 4294967296 , এটা প্রিন্ট করে দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
 int n = 4294967296;
 printf("%d", n);
 return 0;
}

</xmp>
<p>আউটপুট পাচ্ছি শূন্য। ০ ।</p>
<p>4294967297 প্রিন্ট করে দেখলে পাবো ১।</p>
<xmp>

#include <stdio.h>

int main()
{
int n = 4294967297;
printf("%d", n);
return 0;
}

</xmp>

<p>এভাবে যদি 4294967298 প্রিন্ট করি, তাহলে পাবো ২। মানে কি দাড়ালো? মানে 4294967295 এর পরের সংখ্যা গুলো প্রিন্ট করার চেষ্টা করলে আবার ০ থেকে প্রিন্ট করা শুরু করে। সুন্দর একটা কারণ আছে। কারণটা কি? চিন্তা করে বের করতে পারেন।</p>

<p>এতক্ষণ আমরা Unsigned ইন্টিজার সম্পর্কে আলোচনা করেছি। Unsigned মানে হচ্ছে সংখ্যাটা কি ধণাত্ত্বক নাকি ঋণাত্ত্বক, তা বলে দি নি। কিন্তু মাঝে মাঝে আমাদের Singed Integer নিয়ে কাজ করতে হবে। মানে আমরা ভ্যারিয়েবল ডিক্লারেশনের সময় বলে দিব সংখ্যাটা কি ধনাত্ত্বক নাকি ঋণাত্ত্বক, তখন আবার রেঞ্জ ছোট হয়ে যাবে। তখন একটি ইন্টিজারের রেঞ্জ হয়ে যাবে -2,147,483,648 থেকে +2,147,483,647। মানে আমরা  -2,147,483,648 পর্যন্ত এবং 2,147,483,647 পর্যন্ত ইন্টিজার মান একটা ইন্টিজার ভ্যারিয়েবলে সেভ করতে পারব।<br />
ধণাত্ত্বক হলে কম্পাইলার আউটপুটে + চিহ্ন প্রিন্ট করবে না। কিন্তু ঋণাত্ত্বক হলে তা দেখাবেঃ</p>
<xmp>

#include <stdio.h>

int main()
{
int n = -899;
printf("%d", n);
return 0;
}

</xmp>
<p>উপরে একটি ধণাত্ত্বক সংখ্যা আমরা বলতে পারি  Singed Integer ভ্যারিয়েবল তৈরি করা হয়েছে। এবং পরে তা প্রিন্ট করা হয়েছে।</p>

<p>নিচে ভিন্ন ভিন্ন ডেটা টাইপ এবং তাদের সাইজ দেওয়া হলোঃ</p>
<table>
<tbody>
<tr>
<td width="312"> ডেটা টাইপ</td>
<td width="312"> সাইজ</td>
</tr>
<tr>
<td width="312"> int</td>
<td width="312"> 2 bytes</td>
</tr>
<tr>
<td width="312"> char</td>
<td width="312"> 1 byte</td>
</tr>
<tr>
<td width="312"> float</td>
<td width="312"> 4 bytes</td>
</tr>
<tr>
<td width="312"> double</td>
<td width="312"> 8 bytes</td>
</tr>
</tbody>
</table>
<p>বিদ্রঃ এটি কম্পাইলার ভেদে ভিন্ন হতে পারে।</p>
<p><strong>প্রশ্নঃ একটা double ডেটা টাইপ সর্বোচ্চ কত পর্যন্ত সঠিক মান দিতে পারে? </strong></p>


 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3458">

	<div data-role="header">	
	
		<h1>লাইব্রেরী ফাংশন</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>ফাংশান হচ্ছে পুনরায় ব্যবহার যোগ্য কোড ব্লক। যা একটি নির্দিষ্ট কাজ করতে পারে। সি প্রোগ্রামিং এ এমন অনেক গুলো ফাংশন লেখা রয়েছে। যে গুলোকে বলা হয়  লাইব্রেরী ফাংশন। যেমন printf একটি ফাংশন, যার কাজ কোন কিছুর আউটপুট দেখা। আমাদের প্রতিটা প্রোগ্রামের শুরুতেই #include<stdio.h> লেখাটি যুক্ত করি। যার মানে আমরা এর আগেই জেনে এসেছি। মানে হচ্ছে Standard Library Functions টি যুক্ত করা। যেমন আমরা printf ব্যবহার করি, এটি হচ্ছে Standard I/O Functions এর একটা ফাংশন। Standard I/O এ আরো কিছু ফাংশন রয়েছে, যেমনঃ scanf(), getchar(), putchar() ইত্যাদি। এ গুলো সম্পর্কে পরবর্তী চ্যাপ্টার গুলো থেকে জানা যাবে।<br />
নিচে কিচু include file এবং তাদের ফাংশন গুলো দেওয়া হলো। প্রতিটি include file এর ব্যবহার সম্পর্কে বিস্তারিত লেখা লিঙ্কে যুক্ত করা হয়েছে। লিঙ্ক থেকে বিস্তারিত উদাহরণ সহ দেখে নেওয়া যাবে।</p>
<p>কোন ফাংশনে যে মান পাস করা হয়, সে গুলোকে বলা হয়  আর্গুমেন্ট/Argument। কোন কোন লাইব্রেরী ফাংশন কোন Argument ছাড়াই কাজ করে। কোন কোন ফাংশন একটি Argument নেয়। আবার কোন কোন ফাংশন একের অধিক Argument নিয়ে কাজ করে।</p>
<h2><b>stdio.h: I/O functions:</b></h2>
<ol start="1">
<li><b>getchar()</b> returns the next character typed on the keyboard.</li>
<li><b>putchar()</b> outputs a single character to the screen.</li>
<li><b>printf()</b> as previously described</li>
<li><b>scanf()</b> as previously described</li>
</ol>
 
 
<h2><b>string.h: String functions</b></h2>
<ol start="1">
<li><b>strcat()</b> concatenates a copy of str2 to str1</li>
<li><b>strcmp()</b> compares two strings</li>
<li><b>strcpy()</b> copys contents of str2 to str1</li>
</ol>
<p><b>String কি, এর লাইব্রেরী ফাংশন গুলো নিয়ে বিস্তারি জানা যাবে  স্ট্রিং অধ্যায় থেকে</b></p>

<h2><b>ctype.h: Character functions</b></h2>
<ol start="1">
<li><b>isdigit()</b> returns non-0 if arg is digit 0 to 9</li>
<li><b>isalpha()</b> returns non-0 if arg is a letter of the alphabet</li>
<li><b>isalnum()</b> returns non-0 if arg is a letter or digit</li>
<li><b>islower()</b> returns non-0 if arg is lowercase letter</li>
<li><b>isupper()</b> returns non-0 if arg is uppercase letter</li>
</ol>
<ul>
 
</ul>
<h2><b>math.h: Mathematics functions</b></h2>
<ol start="1">
<li><b>acos()</b> returns arc cosine of arg</li>
<li><b>asin()</b> returns arc sine of arg</li>
<li><b>atan()</b> returns arc tangent of arg</li>
<li><b>cos()</b> returns cosine of arg</li>
<li><b>exp()</b> returns natural logarithim e</li>
<li><b>fabs()</b> returns absolute value of num</li>
<li><b>sqrt()</b> returns square root of num</li>
</ol>

<h2><b>time.h: Time and Date functions</b></h2>
<ol start="1">
<li><b>time()</b> returns current calender time of system</li>
<li><b>difftime()</b> returns difference in secs between two times</li>
<li><b>clock()</b> returns number of system clock cycles since program execution</li>
</ol>

<h2><b>stdlib.h:Miscellaneous functions</b></h2>
<ol start="1">
<li><b>malloc()</b> provides dynamic memory allocation, covered in future sections</li>
<li><b>rand()</b> as already described previously</li>
<li><b>srand()</b> used to set the starting point for rand()</li>
</ol>

 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3459">

	<div data-role="header">	
	
		<h1>Assignment operator</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p><strong>Assignment operator:</strong> কোন মান বা Value কোন Identifier [ভ্যারিয়েবল] এর মধ্যে assign করা বা একটা মান রাখার জন্য জন্য assignment operator ব্যবহৃত হয়। C তে অনেক রকম Assignment operator রয়েছে। যেমনঃ</p>
<p>1)    = (Equal to)</p>
<p>2)    +=(Plas equal to)</p>
<p>3)    -=(Mainus equal to)</p>
<p>4)    *=(Product equal to)</p>
<p>5)    /=(Division equal to)</p>
<p>6)    %= (Mode equal to) etc</p>
<p>তবে সবচেয়ে ব্যবহৃত Assignment operator হচ্ছে = (Equal to)।  এটি নিচের from এ লিখা হয়।</p>
<p><strong>Identifier=expression</strong></p>
<p>এখানে Identifier বলতে সাধারনত চলক(variable) কে বুঝানো হয়। আর expression বলতে যে কোন মান যেমন constant বা variable ইত্যাদি কে বুঝানো হয়।</p>
<p>নিচে কিছু Assignment operator এর উদাহরন দেওয়া হলোঃ</p>
<ol>
<li>X=5;</li>
<li>Y=10;</li>
<li>Pi=3.1416</li>
<li>Z=x+y+pi</li>
</ol>
<p>এখানে প্রথম উদাহরনে 5 , x এর মধ্য assign হয়েছে। অর্থাৎ x এর মান এখন 5।  দ্বিতীয় উদাহরনে 10 , y এর মধ্য assign হয়েছে। অর্থাৎ y এর মান এখন 10. তৃতীয় উদাহরনে 3.1416 , pi এর মধ্য assign হয়েছে। অর্থাৎ pi এর মান এখন 3.1416. চতুর্থ উদাহরনে (x+y+pi ) , z এর মধ্য assign হয়েছে। অর্থাৎ z এর মান এখন (x+y+pi ) ।</p>
<p>আমরা এর আগেই  assignment operator ব্যবহার করে এসেছি।</p>
<p>আগের একটি প্রোগ্রামই দেখি, যেখানে আমরা আয়াতাকার  জমির আয়তন বের করেছি।</p>
<xmp>

#include <stdio.h>

int main()
{
 int volume;
 int length = 5;
 int width = 8;
 volume = length * width;
 printf("%d", volume);
 return 0;
}
</xmp>
<p>যেখানে length নামক একটি ভ্যারিয়েবল এ আমরা একটি মান [5] রেখেছি। এবং width ভ্যারিয়েবলে রেখেছি 8.</p>
<p><strong>+= (Plas equal to) Assignment operator:</strong></p>
<p>এটা নিচের মতো করে লেখা হয়</p>
<p>Expression1 += Expression2;</p>
<p>যা (Expression1 = Expression1 + Expression2 ) এর সমান।</p>
<p>ব্যাখ্যাঃ মনে করি x=3 , y=5.</p>
<p>যদি লেখা হয়: x+=y তাহলে x এর মান হবে x=x+y অর্থাৎ x=8.</p>
<xmp>
#include <stdio.h>

int main()
{
 int x =3;
int y = 5;
x +=y;
 printf("%d", x);
 return 0;
}
</xmp>
<p>উপরের প্রোগ্রামটা রান করিয়ে দেখলে আমরা আউটপুট পাবোঃ 8<br />
নিচের প্রোগ্রামটা দেখিঃ</p>
<xmp>
#include <stdio.h>

int main()
{
 int x =3;
int y = 5;
x = x+y;
 printf("%d", x);
 return 0;
}
</xmp>
<p>এ প্রোগ্রামও রান করিয়ে দেখলে আমরা আউটপুট পাবোঃ 8<br />
আউটপুটে কোন পার্থ্যক্য নেই। কম কোড লেখার জন্য প্রায় সময়ই <strong>+= অপারেটর ব্যবহার করা হয়। </strong></p>
<p><strong>-= (Mainus equal to) Assignment operator </strong></p>
<p><strong>-= </strong>এর ক্ষেত্রে নিচের মতো করে লেখা হয়</p>
<p>Exprission1 -= Expression2;</p>
<p>যা (Expression1 = Expression1 - Expression2 ) এর সমান।</p>
<p>ব্যাখ্যাঃ মনে করি x=8 , y=5.</p>
<p>যদি লেখা হয়ঃ x-=y তাহলে x এর মান হবে x=x-y অর্থাৎ x=3.</p>
<xmp>
#include <stdio.h>

int main()
{
 int x =8;
int y = 5;
x -=y;
 printf("%d", x);
 return 0;
}
</xmp>
<p>উপরের প্রোগ্রামটা রান করিয়ে দেখলে আমরা আউটপুট পাবোঃ 3<br />
নিচের প্রোগ্রামটা দেখিঃ</p>
<xmp>
#include

int main()
{
 int x =8;
int y = 5;
x = x-y;
 printf("%d", x);
 return 0;
}
</xmp>
<p>এ প্রোগ্রামও রান করিয়ে দেখলে আমরা আউটপুট পাবোঃ 3<br />
উপরের প্রোগ্রামের সাথে আউটপুটে কোন পার্থ্যক্য নেই।  <strong>+= অপারেটর এর মতই কম কোড লেখার জন্য প্রায় সময় -= ব্যবহার করা হয়। </strong></p>
<p><strong>একই ভাবে  *= এর মানে হচ্ছেঃ</strong></p>
<p>Exprission1 *= Expression2;</p>
<p>যা (Expression1 = Expression1 * Expression2 ) এর সমান।</p>
<p><strong>/= এর মানে হচ্ছেঃ</strong></p>
<p>Expression1 /= Expression2;</p>
<p>যা (Expression1 = Expression1 / Expression2 ) এর সমান।</p>
<p><strong>%= এর মানে হচ্ছেঃ</strong></p>
<p>Expression1 %= Expression2;</p>
<p>যা (Expression1 = Expression1 % Expression2 ) এর সমান।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3460">

	<div data-role="header">	
	
		<h1>গাণিতিক অপারেটর</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>পাটি গণিতে আমরা যে সকল Operators ব্যাবহার করছি তাই হল Arithmetic Operators। যেমন যোগ, গুন, ভাগ ইত্যাদি।</p>
<table style="height: 132px;" border="1" width="582" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="319">Operator</td>
<td valign="top" width="319">ব্যাবহার</td>
</tr>
<tr>
<td valign="top" width="319">+</td>
<td valign="top" width="319">যোগ</td>
</tr>
<tr>
<td valign="top" width="319">-</td>
<td valign="top" width="319">বিয়োগ</td>
</tr>
<tr>
<td valign="top" width="319">*</td>
<td valign="top" width="319">গুণ</td>
</tr>
<tr>
<td valign="top" width="319">/</td>
<td valign="top" width="319">ভাগ</td>
</tr>
<tr>
<td valign="top" width="319">%</td>
<td valign="top" width="319">ভাগশেষ</td>
</tr>
</tbody>
</table>

<p>যোগ, গুন, ভাগ ইত্যাদির তো উদাহরণ দেওয়ার কিছুই নেই, আমরা ইচ্ছে করলেই পারি তাই না? উপরের সকল Operator সম্পর্কে ই আমরা জানি শুধু %(একে Reminder অথবা Mode বলে)  Operator ছাড়া। % এর কাজ একটি উদাহরণ দিয়ে ব্যাখ্যা করি।</p>
<p>মড মূলত ভাগশেষ ভ্যালু। এই Mode (%) নিয়ে কাজ করার একটা সুন্দর নাম রয়েছে, যাকে বলে  Modulus Arithmetic।  Mode এর অনেক কাজ রয়েছে।</p>
<p>বাস্তব একটা উদাহরন দেওয়া যাক।</p>
<p>আমরা সময় হিসেব করি, তা একটা মডুলাস এরিথম্যাটিক বা মডুলাস পাটীগণিত। আমরা যদি ১২ ঘন্টার ঘড়ির কথা চিন্তা করি, তাহলে দেখব ১২ এর পর ১৩ না হয়ে ১ টা ধরি আমরা। আর ঘড়ির এই হিসাবকে বলা যায় ১২ এর মডুলাস এরিথম্যাটিক। আমরা করি কি, প্র্যতকটা ঘন্টাকে ১২ দিয়ে ভাগ করে দি। ১ টা বাজলেও ১২ দিয়ে ভাগ করি। ২ টা বাজলেও। তেমনি ১৫টা বাজলেও। তো যখন ১৫টা বাজে, তখন আমরা মুলত দেখি (১৫%১২) = ৩ বা তিনটা। আস্তে আস্তে আমরা এরকম অনেক গুলো মডুলাস এরিথম্যাটিক নিয়ে কাজ করতে পারব।</p>
<p>মূলত মডের কাজ হচ্ছে একটা লিমিট সেট করে দেওয়া। ঐ লিমিট ক্রস করলে আবার প্রথম থেকে কাউন্ট শুরু হবে। ঘড়ির টাইমের ক্ষেত্রে যেমন, তেমনি।</p>
<p>২৪ ঘন্টার ঘড়ি গুলোতে ২৪ হচ্ছে সর্বোচ্চ ভ্যালু। তো ২৪ এর পর ২৫ না হয়ে হয় (২৫%২৪) = ১।</p>
<p><strong>১৫%৪ = কত হবে?</strong></p>
<p>১৫%৪ এটার উত্তর হবে ৩ কারন ১৫ কে ৪ দ্বারা ভাগ করলে ভাগশেষ থাকে ৩।</p>
<p><strong>মড এর মান সব সময় পূর্ন সংখা হবে।</strong> অর্থাৎ ১৫.৫%৪ এর ভাগ শেষ হচ্ছে ৩.৫ কিন্তু এর মান হবে ৩।</p>
<p><strong>মড সব সময় পজেটিভ হবে।</strong> ১৫%-৪ এর মান হবে ৩। -১৫%৪এর মান হবে -৩। -১৫%-৪এর মান হবে-৩। ইত্যাদি।</p>
<p>নিচের প্রোগ্রামটা দেখিঃ</p>

<xmp>

#include <stdio.h>
int main()
{
int x =11%3;
 printf("%d", x);
 return 0;
}

</xmp>
<p>11 কে ৩ দিয়ে ভাগ করলে ভাগশেষ ২ থাকার কথা, তাই না? তাই আমাদের পোগ্রামের আউটপুট হচ্ছে। 2</p>
<p>#include <stdio.h><br />
int main()<br />
{<br />
int x =12%3;<br />
printf(&#8220;%d&#8221;, x);<br />
return 0;<br />
}</p>
<p>12 কে 3 দিয়ে ভাগ করলে ভাগশেষ ০ থাকার কথা, তাই আমাদের আউটপুটও ০;</p>

 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3461">

	<div data-role="header">	
	
		<h1>ইউনারী অপারেটর</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p><strong>Unary Operators:</strong> C Programming Language এ যে সকল Operator একটি চলকের উপর কাজ করে নতুন মান দেয় তাদের Unary Operators বলে। সবচেয়ে ব্যবহৃত Unary Operators হচ্ছে – (minus sign). – কোন constant অথবা variable এর আগে বসে শুধু negative মান বুঝায়।</p>
<xmp> 
#include <stdio.h>
int main()
{
    int x =-3;
    printf("%d", x);
    return 0;
}
 </xmp>
 
 
<p>যেখানে x এর মান  -3 ;</p>
<p>তবে প্রধান  দুটি Unary Operators হচ্ছে Increment operator(++) ও Decrement operator(- -) ।</p>
<p><strong>Increment operator</strong>: Increment operator কে ++ চিহ্ন দিয়ে প্রকাশ করা হয়। অর্থাত ++ কে increment operator বলে। এটি একটি variable এর উপর বসে এর মান 1 বাড়িয়ে দেয়। এটি variable এর আগে ও বসতে পারে পরেও বসতে পারে। যেমনঃ মনে করি x একটি variable যার মান 5 । ++X এর মান হবে 6 । তেমনি X++ মান ও হবে 6 ।</p>
<xmp> 

#include <stdio.h>
int main()
{
    int x =6;
    x++;
    printf("%d", x);
    return 0;
}
</xmp>

<p>উপরে আমাদের x এর মান 6, এর পর আমরা এর মধ্যে চ্ছে Increment operator(++) ব্যবহার করেছি। এবং শেষে তা প্রিন্ট করেছি। আমরা আউটপুট পেয়েছি 7.</p>
<p>এখন যদি আমরা x আগে ++ দিয়ে প্রিন্ট দি, তাহলেও আমরা একই মান পাবো।</p>
<xmp> 

#include <stdio.h>
int main()
{
    int x =6;
    ++x;
    printf("%d", x);
    return 0;
}
</xmp>
<p>তবে x++ এবং ++x এর মধ্যে একটু পার্থ্যক্য রয়েছে।<br />
x++ এর মানে হচ্ছে আগে x এর মান এক্সিকিউট হবে এবং তারপর এর মান ১ বাড়বে। আর ++x এর মানে হচ্ছে আগে এর মান এক বাড়বে এবং পরে এক্সিকিউট হবে। এখনো যদি বুঝতে অসুবিধে হয় সমস্যা নেই। নিচের প্রোগ্রামটা দেখিঃ<br />
&nbsp;</p>
<xmp>
#include <stdio.h>
 
int main()
{
    int x =3;
    int y =6;
    printf("%d \n", x++);
    printf("%d \n", ++y);
    return 0;
}
</xmp>
<p>উপরের প্রোগ্রামটা যদি আমরা রান করি, তাহলে আমরা আউটপুট পাচ্ছি 3 এবং 7। Increment operator ভ্যারিয়েবল এর পরে রয়েছিল, আমাদের printf ফাংশন আগে x এর মানটা প্রিন্ট করেছে, এর পর এর মান এক বাড়িয়েছে। তাই আমরা আউটপুট পাচ্ছি 3.<br />
কিন্তু y এর ক্ষেত্রে আগে y এর মান এক বাড়িয়েছে, এবং পরে এর মান প্রিন্ট করেছে। তাই আমরা আউটপুট পেয়েছি 7<br />
এখানে দুটা ভ্যারিয়েবল নিয়েছি, এবং পরে তাদের প্রিন্ট করেছি। একটার আগে ++ ব্যবহার করেছি একটার পরে।</p>
<p><strong>Decrement operator</strong>: - - [Minus Minus] কে Decrement operator বলে। এটি একটি variable এর উপর বসে এর মান 1 কমিয়ে দেয়। এটি variable এর আগে ও বসতে পারে পরেও বসতে পারে। যেমনঃ মনে করি x একটি variable যার মান 5 । - -X এর মান হবে 4 । তেমনি X- - মান ও হবে 4 ।</p>
<xmp>
#include <stdio.h>
 
int main()
{
    int x =6;
    x--;
    printf("%d", x);
    return 0;
}
</xmp>

<p>উপরের প্রোগ্রামে আমরা x এর মান সেট করেছি 6 এবং পরে Decrement operator এর উপর প্রয়োগ করেছি। এর পরে এর মান এক কমে গিয়েছে। আমরা পরে x এর মান প্রিন্ট করেছি এবং এর মান পেয়েছি 5.</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3462">

	<div data-role="header">	
	
		<h1>লজিক্যাল অপারেটর</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p><strong>Relational and Logical Operators গুলো হল:</strong></p>
<ol>
<li>Relational  Operators</li>
<li>Equality Operator</li>
<li>Logical Operator</li>
</ol>
<p><strong> </strong></p>
<p>C programming language এ চার প্রকার  Relational Operator রয়েছে:</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="319"><strong>Operator</strong></td>
<td valign="top" width="319"><strong>Meaning</strong></td>
</tr>
<tr>
<td valign="top" width="319"><</td>
<td valign="top" width="319">Less then</td>
</tr>
<tr>
<td valign="top" width="319"><=</td>
<td valign="top" width="319">Less then or equal to</td>
</tr>
<tr>
<td valign="top" width="319">>;</td>
<td valign="top" width="319">Greater then</td>
</tr>
<tr>
<td valign="top" width="319">>;=</td>
<td valign="top" width="319">Greater then or equal to</td>
</tr>
</tbody>
</table>
<p>মনে করি x, y দুটি চলক। x এর মান 5,  y এর  মান 6। সুতরাং x<y  এর মানে হচ্ছে x y থেকে ছোট অর্থাৎ x<y  expression টি সত্য এবং এর মান হবে 1. আবার x>;y  expression টি মিথ্যে এবং এর মান হবে 0.<br />
Relational Operator ব্যবহার করে আমরা সহজেই দুটি সংখ্যার মধ্যে কোনটা ছোট তা বের করে ফেলতে পারি। যা আমরা এর পরের অধ্যায় if - else অংশে  দেখব।</p>
<p><strong>Equality Operator:</strong></p>
<p>RELATIONAL OPERATOR এর সাথে সম্পর্ক যুক্ত দুটি Equality Operator রয়েছে। নিচে এদের দেওয়া হলঃ</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="319"><strong>Operator</strong></td>
<td valign="top" width="319"><strong>Meaning</strong></td>
</tr>
<tr>
<td valign="top" width="319">==</td>
<td valign="top" width="319">Equal to</td>
</tr>
<tr>
<td valign="top" width="319">!=</td>
<td valign="top" width="319">Not Equal to</td>
</tr>
</tbody>
</table>
<p>এখানে প্রথম টি হচ্ছে দুটি সমান চিহ্ন। দুটি মিলেই Equal to  Operator প্রকাশ করে। দ্বিতীয় টি হচ্ছে একটি !(উচ্চারন নট) ও একটি সমান চিহ্ন নিয়ে Not Equal to  Operator প্রকাশ করে।</p>
<p>উদাহরনঃ মনে করি x, y দুটি চলক। x এর মান 5. Y এর মান 6। সুতরাং x==y এর মানে হচ্ছে x এবং y এর মান সমান। কিন্ত আমদের x এবং y এর মান সমান নয়। সুতরাং x==y  expression টি মিথ্যে এবং এর মান হবে 0. আবার x!=y (উচ্চারন x not equal to y) হয় তাহলে expression টি সত্য হয় এবং এর মান হবে 1.</p>
<p>এখানে মনে রাখতে হবে যে Assignment operator = এবং Equality Operator == সম্পূর্নই ভিন্ন। কোন মান বা Value কোন Identifier এর মধ্যে assign বা নির্দিষ্ট করার জন্য assignment operator ব্যবহৃত হয়। আর যেখানে দুইটা Expression এর মান সমান হলে Equality Operator == ব্যবহার করা হয়। Equality Operator দ্বারা Logical True অথাবা False নির্নয় করা হয়।</p>
<p>এখানে একটার স্থানে আরেকটা কোন অবস্থাতেই বসানো যাবেনা। তাহলে Program এ বিশাল ভুল আসবে। প্রথম প্রথম অনেকেই এই ভুল করে।</p>
<p><strong>LOGICAL OPERATOR:</strong></p>
<p>C প্রোগ্রামিং এ দুটি Logical Operator রয়েছে। তাদের নিচে দেওয়া হলঃ</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="319">Operator</td>
<td valign="top" width="319">Meaning</td>
</tr>
<tr>
<td valign="top" width="319">&&</td>
<td valign="top" width="319">And</td>
</tr>
<tr>
<td valign="top" width="319">||</td>
<td valign="top" width="319">Or</td>
</tr>
</tbody>
</table>
<p>&& কে বলা হয় Logical and এবং || কে বলা হয় Logical Or.</p>
<p><strong>&&(পড়া হয় And)  operator :</strong></p>
<p>মনে করি x,y,z তিনটি চলক। এখন (x<y)&& (y<z) হচ্ছে একটি expression. এখন এর মান সত্য হবে যদি (x<y) এবং (y<z) সত্য হয়। (x<y) এবং (y<z) এর যে কোন একটি মিথ্যা হলে (x<y)&& (y<z) এর মান মিথ্যে হবে।</p>
<p><strong>||(পড়া হয় Or Or)  operator :</strong></p>
<p>মনে করি x,y,z তিনটি চলক। এখন (x<y)||(y<z) হচ্ছে একটি expression. এখন এর মান সত্য হবে যদি (x<y) এবং (y<z) সত্য হয়। অথবা (x<y) এবং (y<z) এর যে কোন একটি সত্য হয়। (x<y) এবং (y<z) দুটি একসাথে মিথ্যা হলে (x<y)||(y<z) এর মান মিথ্যে হবে।</p>
<p>RELATIONAL AND LOGICAL OPERATORS এর কয়েকটি উদাহরন নিচে দেওয়া হল:</p>
<p>মনে করি x, y, z তিনটি চলক। x এর মান 5. y এর  মান 6 এবং z এর মান 7।</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="213">Expression</td>
<td valign="top" width="213">ব্যাখ্যা</td>
<td valign="top" width="213">মান</td>
</tr>
<tr>
<td valign="top" width="213">X<y</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">X==5</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">y==4</td>
<td valign="top" width="213">False</td>
<td valign="top" width="213">0</td>
</tr>
<tr>
<td valign="top" width="213">(X+y)>;z</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">(X+y)<=z</td>
<td valign="top" width="213">False</td>
<td valign="top" width="213">0</td>
</tr>
<tr>
<td valign="top" width="213">X!=y</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">(X<y)&&(y==6)</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">(X<y)&&(z!=y)</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">(X>;y)||(z!=y)</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
<tr>
<td valign="top" width="213">(X>;y)&&(z!=y)</td>
<td valign="top" width="213">False</td>
<td valign="top" width="213">0</td>
</tr>
<tr>
<td valign="top" width="213">(X<y)&&(z==y)</td>
<td valign="top" width="213">False</td>
<td valign="top" width="213">0</td>
</tr>
<tr>
<td valign="top" width="213">(X<y)||(z==y)</td>
<td valign="top" width="213">True</td>
<td valign="top" width="213">1</td>
</tr>
</tbody>
</table>
<p>অর্থাৎ সকল true এর মান 1 এবং false এর মান ০।</p>
<h2></h2>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3463">

	<div data-role="header">	
	
		<h1>কন্ডিশনাল অপারেটর</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>Conditional Operator: একটা condition দিয়ে দুটি মান select করার একটা পদ্ধতি। এটি নিচের মতো করে লেখা হয়ঃ</p>
<p>Expression1? Expression2: Expression3</p>
<p>যেমনঃ</p>
<p>মনে করি i=5, তাহলে নিচের Conditional Operator টা দেখিঃ</p>
<p>Z=(i<8)?10:100;



এখানে Z এর জন্য Conditional Operator টা লেখা হয়েছে। এখানে লিখা হয়েছেঃ Z=(i<8)?10:100; অর্থাত যদি i এর মান 8 থেকে ছোট হয় তাহলে Z এর মান হবে 10। আর তা না হলে z এর মান হবে 100.

আমি নিচের প্রোগ্রামে সব কিছু বুঝানোর চেষ্টা করছিঃ

if-else statement এর পরিবর্তে Conditional Operator (?:) ব্যবহার করে সহজেই দুইটি statement অথবা valu এর মধ্যে তুলনা করে একটি মান নির্বাচিত করা যায়। Conditional Operator সি প্রোগ্রামিং এ নিচের মত করে লেখা হয়ঃ

condition ? first_expression : second_expression;

এখানে condition  হচ্ছে যে কোন একটা শর্ত। যা সত্য হলে   first_expression নির্বাচিত হবে। আর কন্ডিশন ভুল হলে second_expression।
নিচে ছোট্ট একটা প্রোগ্রাম। যা দিয়ে দুটি সংখ্যার মধ্যে বড়টা নির্বাচিত  করা হয়েছে।


<xmp>

#include <stdio.h>
int main()
{
 int x, y , result;
 scanf("%d %d", &x , &y);
 result = (x>;=y) ? x : y ;
 printf("max is %d", result);
 return 0;
}

</xmp>
<p>একই প্রোগ্রাম, কন্ডিশন পরিবর্তন করে  দুটি সংখ্যার মধ্যে ছোটটা নির্বাচিত  করা হয়েছে।</p>
<xmp>

#include <stdio.h>

int main()
{
 int x, y , result;
 scanf("%d %d", &x , &y);
 result = (x<=y) ? x : y ;
 printf("min is %d", result);
 return 0;
}

</xmp>
<p>যদিও একই কাজ if -else বা অন্য অনেক ভাবে করা যায়।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3464">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিং -  getchar & putchar</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>এতক্ষন পর্যন্ত আমরা একটি ডেটা শুধু আউটপুট দিয়েছি। কিন্তু আমাদের প্রোগ্রামে আমরা শুধু কিছু মান আউটপুটই নিব না, ব্যবহারকারী থেকে কিছু ইনপুটও নিতে হবে। ইনপুট এবং আউটপুটের জন্য আজকে দুটি Function নিয়ে আলোচনা করব। একটা হচ্ছে “<strong><em>getcha</em></strong>r” আরেকটি হচ্ছে “<strong><em>putchar</em></strong>” Function.</p>
<h2><strong>getchar:</strong></h2>
<p><strong><em>getchar</em></strong> Function দ্বারা single character কম্পিউটারে input নেওয়া হয়। এটি একটি C library Function. এটি সাধারণত নিছের মত করে লিখা হয়।</p>
<xmp>character variable = getchar( ); </xmp>
<p><strong><em>getchar</em></strong> Function হচ্ছে স্টান্ডার্ড C I/O library এর একটি অংশ। এটি ইনপুট ডিভাইস যেমন Keyboard থেকে একটি সিঙ্গেল Character দেয়।   প্রোগ্রামের মঝে এটি নিচের মত করে লিখা হয়ঃ</p>
<xmp>char x;
x = getchar();
</xmp>
<p>এখানে char x; দ্বারা বুঝানো হয়েছে যে এটি একটি character type Variable. পরবর্তিতে <strong><em>x= getchar();</em></strong> দ্বারা x এর মান ইনপুট ডিভাইস [ কীবোর্ড ] হতে নিবে। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp>

#include <stdio.h>

int main()
{
char x;
printf("Enter a character: ");
 x = getchar();
 return 0;
}

</xmp>
<p>উপরের প্রোগ্রামটা রান করুন এবং কীবোর্ড হতে একটি বর্ণ টাইপ করে এন্টার কী প্রেস করুন। কোন আউটপুট পাচ্ছি না। কারণ আমরা ইনপুট নিয়েছি। আউটপুট দি নি। আউটপুটের জন্য আরেকটা ফাংশন ব্যবহার করব। putchar</p>
<h2><strong><em>putchar Function:</em></strong></h2>
<p><strong><em>putcha</em></strong>r Function দ্বারা single character কনসোলে  দেখানোর জন্য ব্যবহার করা হয়।   এটি getchar Function অনুরুপ। এটি সাধারনত নিছের মত করে লিখা হয়।</p>
<xmp>putchar(character variable );</xmp>
<p>এটি ও স্টান্ডার্ড  I/O library এর একটি অংশ।  প্রোগ্রামের মঝে এটি নিচের মত করে লিখা হয়ঃ</p>
<xmp>char x;
putchar(x);
</xmp>
<p><strong><em>getchar </em></strong>Function  এর মত এখানে char x; দ্বারা বুঝানো হয়েছে যে এটি একটি character type Variable. পরবর্তিতে putchar(x); দ্বারা x এর মান আউটপুট ডিভাইসে দেখাবে।</p>
<xmp>

#include <stdio.h>
int main()
{
 char x;
 x= getchar();
 putchar(x);
 return 0;
}

</xmp>
<p>উপরের প্রোগ্রামে একটি character variable  <strong>x<em> </em></strong>নিয়েছি। এখন প্রোগ্রামটি রান করার পর আপনি যাই ইনপুট দিবেন,<b><i> </i></b> <strong><em>putcha</em></strong>r Function দ্বারা আপনাকে দেখাবে।</p>
<p><strong>ছোট অক্ষরকে বড় অক্ষরে পরিনত করাঃ</strong></p>
<xmp>

#include <stdio.h>

int main()
{
 char x;
 x= getchar();
 putchar(toupper(x));
 return 0;
}

</xmp>
<p>এ প্রোগ্রাম এ যে Character ই input হিসেবে নিবে তার Uppercase মানে বড় হাতের অক্ষর Output দিবে। আর বড় হতের দিলে ও বড় হাতের অক্ষর Output দিবে। তবে সংখা দিলে তাই Output দিবে।</p>
<p>এখানে আমরা toupper() নামক লাইব্রেরী ফাংশং ব্যবহার করেছি। নাম থেকেই তো এর কাজ বুঝা যায় তাই না?</p>
<p>বড় অক্ষরকে ছোট অক্ষরে পরিনত করাঃ</p>
<xmp>

#include <stdio.h>

int main()
{
char x;
x= getchar();
putchar(tolower(x));
return 0;
}

</xmp>
<p>এ প্রোগ্রাম এ যে Character ই input হিসেবে নিবে তার Lowercase মানে ছোট হাতের অক্ষর Output দিবে। আর ছোট হতের দিলে  তাই Output দিবে।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3465">

	<div data-role="header">	
	
		<h1>scanf & printf</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>আমরা এর আগে আমরা একটি মাত্র  character কম্পিউটারে কিভাবে getchar এর সাহায্যে input নেওয়া যায় তা দেখছি। এবার আমরা single character, numerical values এবং string কিভাবে কম্পিউটারে input নিব তা দেখবো। single character, numerical values. এবং string যেকোন মান কম্পিউটারে নেওয়ার জন্য “scanf” function ব্যবহার করা হয়। আবার putchar এর মত কোন মান পর্দায় দেখানোর জন্য “printf” function ব্যবহার করি যা আমরা এর আগেই ব্যবহার করা শুরু করেছি। putchar দিয়ে একটি মাত্র character কম্পিউটারে Output দেখানো যেত, কিন্তু “printf” function দ্বারা একদিক ডাটা যেমন single character, numerical values. এবং string ইত্যাদির যেকোন মান কনসোলে আউটপুট দেখানো যায়।</p>
<h3>“scanf” function ব্যবহারের নিয়মঃ</h3>
<xmp>

scanf(control string, argument1, argument2,……..argumentn);

</xmp>
<p>এখানে <em>control string</em> দ্বারা কোন ধরনের Data input নিব তার ফরমেট বুঝায়। আর <em> argument</em> দ্বারা Data কম্পিউটারে কোথায় (memory address এর কোন জাগায়) সংরক্ষন হবে তা বুঝায়।</p>
<p>যেমন একটি প্রোগ্রামে নিচের মত করে   <em>Scanf</em>  ব্যবহার করা হয়ঃ</p>
<xmp>

char name;
scanf(“%c”,&name);
</xmp>
<p>এখানে <em>name</em> নামে একটি variable নেওয়া হয়েছে। তার পর আমরা এখন ইনপুট ডিভাইস থেকে এ চলকের মান  কম্পিউটারে নিব। এ জন্য <em>Scanf(“%c”,&name);</em> statement দিয়ে তা নেওয়া হয়েছে।</p>

<p>এখানে <em>control string</em> হচ্ছে c। প্রতিটি <em>control string</em> একটি % চিহ্ন দিয়ে শুরু করতে হয়। তাই এখানে <em>control string </em>টি <em>%c</em> দ্বারা লিখা হয়েছে।  <em>control string</em>  কে প্লেসহোল্ডার ও বলা হয়। এখানে c দ্বারা বুঝানো হয় যে Data item একটি single character। এরকম আরো অনেক গুলো <em>control string</em> রয়েছে।</p>
<p>scanf নিয়ে সম্পুর্ণ একটা প্রোগ্রামঃ</p>

<xmp> 
#include <stdio.h>
int main(void)

{
	float gpa;
	printf("Enter your SSC GPA:" );
	scanf("%f",&gpa);
	printf("You SSC GPA: %f \n",gpa);
	return 0;
}
</xmp>
<p>নিছে এর একটি তালিকা দেওয়া হল।</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="79">Code</td>
<td valign="top" width="559">Meaning</td>
</tr>
<tr>
<td valign="top" width="79">%a</td>
<td valign="top" width="559">Input হিসেবে Floating-point  Data item  নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%c</td>
<td valign="top" width="559">Input হিসেবে একটি মাত্র character Data item নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%d</td>
<td valign="top" width="559">Input হিসেবে Decimal integer Data item নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%e</td>
<td valign="top" width="559">Input হিসেবে Floating-point  Data item  নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%f</td>
<td valign="top" width="559">Input হিসেবে Floating-point  Data item  নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%g</td>
<td valign="top" width="559">Input হিসেবে Floating-point  Data item নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%i</td>
<td valign="top" width="559">Input হিসেবে Decimal, Hexadecimal or Octal Integer Data item  নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%o</td>
<td valign="top" width="559">Input হিসেবে Octal Integer Data item  নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%p</td>
<td valign="top" width="559">Input হিসেবে Pointer Data item নিতে পারবে।( Pointer সম্পর্কে পরে আলোচনা করা হবে)।</td>
</tr>
<tr>
<td valign="top" width="79">%s</td>
<td valign="top" width="559">Input হিসেবে String   Data item নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%u</td>
<td valign="top" width="559">Input হিসেবে Unsigned decimal Data item নিতে পারবে।</td>
</tr>
<tr>
<td valign="top" width="79">%x</td>
<td valign="top" width="559">Input হিসেবে Hexadecimal Data item নিতে পারবে।</td>
</tr>
</tbody>
</table>
<p><strong>control string কে কেউ কেউ আবার Placeholder ও বলে থাকে। </strong></p>
<h2>“printf” function ব্যবহারের নিয়মঃ</h2>
<xmp>

printf(control string, argument1, argument2,……..argumentn);

</xmp>
<p>এখানে <em>control string</em> দ্বারা কোন ধরনের Data Output দিবে তার ফরমেট বুঝায়। আর <em> argument</em> দ্বারা প্রতিটি Output Data প্রকাশ করে। এখানে কিন্তু “scanf” function এর মত memory address প্রকাশ করে না।</p>
<p>যেমন একটি প্রোগ্রামে নিচের মত করে   “printf”  ব্যবহার করা হয়ঃ</p>
<xmp>

char name;
printf(“%c”, name);

</xmp>
<p>এখানে <em>name</em> নামে একটি Character variable নেওয়া হয়েছে। এখন মনে করি <em>name </em>এর মান কম্পিউটারে আছে আমরা তার Output বের করবো। তাই printf<em>(“%c”, name);</em> দ্বারা তা Output ডিভাইসে প্রকাশ করে। এখানে ও <em>control string</em> হচ্ছে c। scanf এর মর printf এ ও প্রতিটি <em>control string</em> একটি % চিহ্ন দিয়ে শুরু করতে হয়। তাই এখানে <em>control string </em>টি <em>%c</em> দ্বারা লিখা হয়েছে। এখানে c দ্বারা বুঝানো হয় যে Data item একটি single character। scanf ও printf এর <em>control string</em> একই।  scanf এর <em>control string</em> দ্বারা কি ধরনের মান ইনপুট নিবে তা বুঝায়, আর printf এর <em>control string</em> দ্বারা কিধরনের মান আউটপুট দিবে তা বুঝায়।</p>
<p>printf ব্যবহার করে আমরা অনেক প্রোগ্রাম লিখেছি। আরেকটা লিখিঃ<br /></p>

<xmp> 
#include <stdio.h>
int main(void)

{
	int roll;
	printf("Can you remember your roll no in class one?\nIf yes, please enter: " );
	scanf("%d",&roll);
	printf("Your roll was: %d \n",roll);
	return 0;
}
</xmp>

<p>নিচে printf এর <em>control string</em> বা প্লেসহোল্ডার গুলো দেওয়া হল।</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="79">Code</td>
<td valign="top" width="559">Meaning</td>
</tr>
<tr>
<td valign="top" width="79">%a</td>
<td valign="top" width="559">এটি ব্যবহার করলে Floating-point  Data item  আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%c</td>
<td valign="top" width="559">এটি ব্যবহার করলে একটি মাত্র character Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%d</td>
<td valign="top" width="559">এটি ব্যবহার করলে Decimal integer Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%e</td>
<td valign="top" width="559">এটি ব্যবহার করলে Floating-point  Data item  আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%f</td>
<td valign="top" width="559">এটি ব্যবহার করলে Floating-point  Data item  আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%g</td>
<td valign="top" width="559">এটি ব্যবহার করলে Floating-point  Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%i</td>
<td valign="top" width="559">এটি ব্যবহার করলে Decimal, Hexadecimal or Octal Integer Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%o</td>
<td valign="top" width="559">এটি ব্যবহার করলে Octal Integer Data item  আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%p</td>
<td valign="top" width="559">এটি ব্যবহার করলে Pointer Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%s</td>
<td valign="top" width="559">এটি ব্যবহার করলে String   Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%u</td>
<td valign="top" width="559">এটি ব্যবহার করলে Unsigned decimal Data item আউটপুট দিবে।</td>
</tr>
<tr>
<td valign="top" width="79">%x</td>
<td valign="top" width="559">এটি ব্যবহার করলে Hexadecimal Data item আউটপুট দিবে।</td>
</tr>
</tbody>
</table>
<p>এবার আমরা scanf ও printf এর ব্যবহারের উপর একটি ছোট্ট প্রোগ্রাম দেখিঃ<br /></p>

<xmp>
#include <stdio.h>
int main(void)

{
	char name[80];
	scanf("%s",&name);
	printf("You enter: %s",name);
	return 0;
}
</xmp>

<p>এখানে একটি name নামে একটি character array (array সম্পর্কে পরে আলোচনা করা হবে) নেওয়া হয়েছে, যা মোট ৮০ টি character ধারন করতে পারবে(আসলে ৭৯ টি আরেকটি Null Character, যা সম্পর্কে পরে আলোচনা করা হবে) । তার পর এর মান ইনপুট ডিভাইস হতে নেওয়া হবে scanf function দ্বারা। scanf এর ভিতর %s দ্বারা বুঝানো হয়েছে যে এটি একটি String Input নিবে। তার পর এ মান printf(&#8220;%s&#8221;,name); দ্বারা পর্দায় আউটপুট দেখানো হয়েছে।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3466">

	<div data-role="header">	
	
		<h1>প্রাথমিক ধারনা</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>প্রোগ্রামিং মানে হচ্ছে লজিক। আর আমাদের লজিক গুলো কম্পিউটারকে জানাতে ব্যবহার করা হয়  কন্ট্রোল স্টেটমেন্টস (Control Statements)।</p>
<p>এর আগে আমরা যত গুলো প্রোগ্রাম দেখেছি, সব গুলো শুধু মাত্র কিছু ডেটা ইনপুট নিয়েছে বা কিছু ডেটা আউটপুট দিয়েছে। কিন্তু কোন লজিক্যাল তুলনা করি নি। আমাদের যে সব প্রোগ্রাম লিখতে হবে, সে গুলোতে অনেক লজিক্যাল তুলনা করতে হবে। যেমন আমরা ৩টি সংখ্যার মধ্যে সবচেয়ে ছোট বা সবচেয়ে বড় সংখ্যা নির্ণয়ের ফ্লো চার্ট যদি দেখি, তাহলে দেখতে পাবো ঐখানে কিছু জায়গায় হ্যা অথবা না স্টেপ রয়েছে। আর ঐ ধরনের স্টেপ গুলোকে বলে লজিক্যাল স্টেপ। লজিক্যাল স্টেপ গুলোকে প্রোগ্রামে প্রকাশ করা হয় এই কন্ট্রোল স্টেটমেন্ট দিয়ে।</p>
<p>কন্ট্রোল স্টেটমেন্ট গুলোর মধ্যে রয়েছেঃ</p>

<ul>
<li>if-else Statement</li>
<li>while Statement</li>
<li>do-while  statement</li>
<li>for statement ইত্যাদি।</li>
</ul>
<p>উপরের লিঙ্ক গুলো তে ক্লিক করে বা সাইডবার থেকে এ কন্ট্রোল স্টেটমেন্ট গুলো সম্পর্কে বিস্তারিত জানা যাবে।</p>

<p>এগুলো জেনে আমরা সত্যিকারের প্রোগ্রামিং জগতে প্রবেশ করতে যাচ্ছি। যে যত সহজে কন্ট্রোল স্টেটমেন্ট গুলো দিয়ে নিজের লজিক গুলো কোডে পরিনত করতে পারবে, সে দ্রুত প্রোগ্রামিং এ ভালো করতে পারবে </p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3467">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিংঃ if - else</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>একটা লজিক্যাল টেস্ট যদি সত্য হয়, তাহলে কিছু কাজ করবে। যদি মিথ্যে হয়, তাহলে অন্য কাজ। এ লজিক থেকেই if else. যেমনঃ যদি আজ শুক্রবার হয়, ঘুমাবো। না হলে ব্যাগ গুছিয়ে স্কুল/কলেজে যাবো। এমন ধরনের &#8220;যদি, তা নাহলে&#8221; থেকেই if - else।</p>

 <xmp>
if(expression) statement 1
else statement2;
</xmp>

<p>এখানে এই statement দিয়ে বুঝানো হয়, যদি Expression টি সত্য হয় তাহলে statement 1 কাজ করবে। আর যদি মিথ্যে হয় তাহলে statement2 টি কাজ করবে। একটা প্রোগ্রাম লিখে ফেলিঃ</p>
<xmp>
#include <stdio.h>
int main(void)
{
	int day;
	printf("Enter value of X: ");
	scanf("%c",&day);
	if((day=='F')|| (day=='f')){
      printf("You can sleep today! :D");
	} else {
        printf("oh no! have to go to class :'( ");
	}
	return 0;
}
</xmp>
 
<p>এখানে করছি কি, আমরা আজকের দিনের প্রথম অক্ষর ইনপুট নিয়েছি এবং তা day নামক ভ্যারিয়েবলে রেখেছি। তারপর if(day==&#8217;F&#8217;) এখানে একটা লজিক্যাল টেস্ট করেছি। যদি day এর মান F [মানে ফ্রাইডে, শুক্রবার] কারেকটারের সাথে মিলে, তাহলে প্রিন্ট করবে &#8220;You can sleep today! :D&#8221; কারণ আজ শুক্রবার। আর যদি অন্য কোন  কারেকটার ইনপুট দেয়, মানে সপ্তাহের অন্য কোন দিন হয়, তাহলে লেখা উঠবে &#8220;oh no! have to go to class :'(&#8221;</p>
<p>if - else  সহজ, তাই না?</p>
<p>উপরের প্রোগ্রামে হয়তো কেউ কেউ শুক্রবারের প্রথম লেটার হিসেবে F অথবা f যে কোন একটা দিতে পারে। এখন কেউ যদি উপরের প্রোগ্রামে f ইনপুট দেয়, তাহলেও লেখা উঠবে &#8220;oh no! have to go to class :'(&#8221; । অথচ আজ শুক্রবার। আমাদের প্রোগ্রামটি ঠিক করতে হবে। যেন কেউ  F অথবা f যে কোন একটা ইনপুট দিলেই লেখা উঠে  &#8220;You can sleep today! :D&#8221;</p>
<p>তার জন্য নিচের প্রোগ্রাম লিখিঃ</p>


<xmp> 
#include <stdio.h>
int main(void)
{
	int day;
	printf("Enter value of X: ");
	scanf("%c",&day);
	if((day=='F')|| (day=='f')){
      printf("You can sleep today! :D");
	} else {
        printf("oh no! have to go to class :'( ");
	}
	return 0;
}
</xmp>
<p>আমরা কন্ডিশনটা একটু পরিবর্তন করেছি। লিখছি: if ((day==&#8217;F&#8217;)|| (day==&#8217;f&#8217;))</p>
<p>এখানে || মানে or মানে অথবা। আমরা তা লজিক্যাল অপারেটর সেকশনে জেনেছি। এখন (day==&#8217;F&#8217;) অথবা (day==&#8217;f&#8217;) যে কোন একটা সত্য হলেই আমাদের প্রোগ্রাম প্রিন্ট করবে &#8220;You can sleep today! :D&#8221; অন্যথায় প্রিন্ট করবে &#8220;oh no! have to go to class :'(&#8221;</p>

<p>if -else এ কিন্তু else না থাকলে ও হয়। এটা একটি বাড়তি অংশ। নিচে কয়েকটি statement দেওয়া হলঃ</p>
<xmp>

if (x==1) pfrintf(“%d”,1);

</xmp>
<p>এখানে যদি x=1 হয় তাহলে pfrintf(“%d”,1); statement টি কাজ করবে এবং 1 Print করবে। আর যদি x=1 না হয় তাহলে pfrintf(“%d”,1); statement টি কাজ করবে না। সম্পুর্ণ একটি প্রোগ্রামঃ</p>
<xmp> 
#include <stdio.h>
int main(void)
{
	int x;
	printf("Enter value of X: ");
	scanf("%d", &x);

	if(x==1){
      	printf("value of X is 1");
	}
	return 0;
}

</xmp>

<xmp>

    if(a>;b) printf("a is greater then b");
    else printf("a is less then or equal to b");

</xmp>
এখানে যদি a&lt;b হয়, মানে a যদি  b থেকে ছোট হয় তাহলে printf(“a is greater  then b”); statement টি কাজ করবে এবং a is grater then b লেখা টি প্রিন্ট করবে। আর যদি a&lt;b না হয় তাহলে printf(“a is greater  then b”); কাজ করবে না। else অংশে যাবে এবং printf(“a is less then b”); statement টি কাজ করবে তারপর a is less then b লেখাটি প্রিন্ট করবে।
 
 
 সম্পুর্ণ প্রোগ্রামঃ<br />
 <xmp>
#include<stdio.h>
int main(void)
{
    int a,b;
    printf("input the valu of a:");
    scanf ("%d",&a);
    printf("input the valu of b:");
    scanf ("%d",&b);
    if(a>b) printf("a is greater then b");
    else printf("a is less then or equal to b");

    return 0;
}
 
 </xmp>
 
<p>শুধু মাত্র if statement ব্যবহার করে দুটি সংখ্যার মধ্যে ছোট বড় নির্নয়ের জন্য একটি প্রোগ্রাম লিখিঃ</p>
<xmp>
#include<stdio.h>
int main(void)
{
    int x,y;
    
    printf("input the valu of x:");
    scanf ("%d",&x);
    
    printf("input the valu of y:");
    scanf ("%d",&y);
    
    if(x>y) printf("x is greater then y\n");
    if(x<y)printf("x is less then y\n");
    if(x==y)printf("x is equal to y\n");
    
    return 0;
}

</xmp>
<p>এ প্রোগ্রামে আপনার কাছ থেকে দুটি নাম্বার ইনপুট নিবে। তার পর তাদের মধ্যে কোনটা বড়, ছোট বা সমান তা দেখাবে। If-else statement ব্যবহার করে দুটি সংখ্যার মধ্যে ছোট বড় নির্নয়ের জন্য একটি প্রোগ্রাম লিখিঃ<br /></p>
<xmp>
#include<stdio.h>
int main(void)
{
    int x,y;
    printf("input the valu of x:");
    scanf ("%d",&x);
     
    printf("input the valu of y:");
    scanf ("%d",&y);
     
    if(x>y) printf("x is greater then y\n");
    else printf("x is less then y\n");
}
</xmp>

<p>এখানের প্রোগ্রামটি আগের টির মতই। তবে এখানে equality দেখাবে না। equality  দেখার জন্য নিচের প্রোগ্রামটি দেখিঃ<br /></p>
<xmp>
#include<stdio.h>
int main(void)
{
    int x,y;
    printf("input the valu of x:");
    scanf ("%d",&x);

    printf("input the valu of y:");
    scanf ("%d",&y);

    if(x>y) printf("x is greater then y\n");
    if(x==y) printf("x is equal to y\n");
    else printf("x is less then y\n");
}
</xmp>

<p>পাস এবং ফেল নির্নয় জন্য একটি প্রোগ্রামঃ</p>
<xmp>
#include<stdio.h>
int main(void)
{
    int x;
    printf("input your number:");
    scanf ("%d",&x);
     
    if (x>40 && x<100)
    printf("Congratulation!!! You have passed");
    else("Ops!! You have failed.");
}

</xmp>
<p>এখানে যদি এক্সামের মার্ক ইনপুট দেওয়া হয়ত, তাহলে পাস করছে নাকি ফেল করছে তা দেখাবে।</p>
<h2>nested if-else</h2>
<p>একটা if ব্লকের ভেতর যদি আরেকটা if/else ব্লক লিখি, তাই হচ্ছে nested if-else। নিচের প্রোগ্রামটি দেখিঃ<br /></p>

<xmp>
#include <stdio.h>
int main ()
{
  int grade;
  printf("Type in your grade: ");
  scanf ("%d", &grade);

  if (grade < 10){
    printf ("Oh no!");
  }
  else{
    if (grade < 40){
      printf ("You failed.\n");
    }
    else{
      printf ("You passed!\n");
      if (grade >= 90){
        printf ("And you got an A!\n");
      }
    }
  }
  return 0;
}
 </xmp>


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3468">

	<div data-role="header">	
	
		<h1>while</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>while লুপের সাধারণ ফরম হচ্ছেঃ</p>
<p><strong><em>while (expression) statement</em></strong></p>
<p>expression বলতে একটা কন্ডিশন দেওয়া হয়। যতক্ষণ  পর্যন্ত এই কন্ডিশনটি সত্য হবে, ততক্ষন পর্যন্ত while লুপটি চলবে। ছোট্ট একটা প্রোগ্রাম লিখিঃ</p>
<xmp>
#include <stdio.h>
int main ( ){
 
int number = 0;
while (number <=9){
		printf("%d \n", number);
		number++;
	}
}
</xmp>
<p>উপরের প্রোগ্রামে আমরা number নামে একটা ইন্টিজার ভ্যারিয়েবল নিয়েছি। যার প্রাথমিক মান হচ্ছে ০। এরপর আমরা while লুপ লিখছি।  (number <=9) এটা হচ্ছে কন্ডিশন। যতক্ষন পর্যন্ত এ কন্ডিশনটা সত্য হবে, ততক্ষণ পর্যন্ত ব্র্যাকেটের ভেতরের  {&#8230;} কোড গুলো এক্সিকিউট হবে। ব্র্যাকেটের ভেতরে আমরা প্রথমে নাম্বারটি প্রিন্ট করেছি। পরের লাইনে number++; দিয়ে নাম্বারটির মান এক করে বাড়িয়ে দিয়েছি।</p>

<p>প্রথমে number ভ্যারিয়েবলটির ভ্যালু ছিল ০&#8230; প্রথমে while লুপের ভেতর ঢুকে নাম্বারটি প্রিন্ট করল। এরপর number++; দিয়ে নাম্বারেরর ভ্যালু এক বাড়িয়ে দিল। এখন number ভ্যারিয়েবল এর মান ১ এরপর আবার লুপের প্রথমে ফিরে গেলো। গিয়ে কন্ডিশনটি (number <=9) চেক করল। number ভ্যারিয়েবলের মান কি ৯ অথবা এর থেকে ছোট? যেহেতু নাম্বার ভ্যারিয়েবলের মান ১, এবং ৯ থেকে ছোট। তাই আবার লুপের ভেতরে ঢুকবে। এবং আবার প্রিন্ট করবে। এবার প্রিন্ট করবে 1. আবার number++; দিয়ে ভ্যালু এক বাড়িয়ে দিবে, মান হবে ২। এবং আবার লুপের প্রথমে গিয়ে চেক করবে। যখন দেখবে ৯ থেকে ছোট, তখন লুপের ভেতরে ঢুকবে। এবং আবার number টি প্রিন্ট করবে। ১০ বার লুপে ঢুকবে।</p>
<p>শেষ বার যখন number++ দিয়ে এক মান বাড়িয়ে দিবে, তখন number ভ্যারিয়েবল এর মান হবে 10 এবং যখন কন্ডিশনটি চেক করবে, তখন দেখবে number ভ্যারিয়েবলের মান ৯ থেকে বেশি। তখন আর while লুপটি কাজ করবে না। প্রোগ্রামটি শেষ হবে।</p>

 আমরা আরেকটা প্রোগ্রাম লিখতে পারি। ছোট বেলায় দুষ্টুমি করলে মাঝে মাঝে শিক্ষক বা বাড়িতে তো ১০০ বার লিখতে দিত, &#8220;আমি আর দুষ্টুমি করব না।&#8221; তখন যদি আমরা প্রোগ্রামিং জানতাম, আমাদের এত কষ্ট করতে হতো না। কয়েক লাইনের কোড লিখলেই ১০০ বার লেখা হয়ে যেতো। চাইলে তখন ১০০০ বার বা ১লক্ষ বার ও লিখে দেওয়া যেত। while লুপ দিয়ে এই প্রোগ্রামটি লিখি। প্রোগ্রামের ভেতর বাংলিশে লিখলাম &#8220;ami r dustumi korbo na&#8221;<br />
&nbsp;<br />

<xmp>
#include <stdio.h>
int main ( ) {
 
int number = 1;
while (number <=100){
		printf("ami r dustumi korbo na. \n");
		number++;
	}
}
</xmp>

<p>প্রোগ্রামটি রান করলে দেখব, কনসোলে ১০০ বার লেখা উঠে, আমি আর দুষ্টুমি করব না।</p>
<p>এখানে এর আগের প্রোগ্রামের মত একই কাজই করা হয়েছে। আগের প্রোগ্রামে নাম্বার ভ্যারিয়েবলটি প্রিন্ট করা হয়েছে। এখন প্রিন্ট করা হয়েছে একটি স্টিং।</p>
<p>প্রতিবার স্টিংটি প্রিন্ট করার পর number ভ্যারিয়েবল এর মান এক করে বাড়িয়ে দেওয়া হয়েছে। এবং while লুপের প্রথমে গিয়ে কন্ডিশনটি চেক করা হয়েছে। যতক্ষন পর্যন্ত দেখল number এর মান ১০০ থেকে ছোট বা সমান, ততক্ষণ পর্যন্ত লুপটি চলেছে। এবং যখনি number এর মান ১০১ এক হয়েছে, তখন লুপের কাজ শেষ হয়েছে।</p>

<p>while লুপ দিয়ে আরেকটি প্রোগ্রাম লিখতে পারি। 1 থেকে 100 পর্যন্ত বেজোড় সংখ্যা গুলো প্রিন্ট করতে পারি। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp>
#include <stdio.h>
int main ( )
{
int number = 0;
while (number <=100){
    printf("%d \n", number);
    number = number + 2;
    }
}
</xmp>

<p>এক এর থেকে দুই যোগ করলে হবে তিন। একটা বিজোড় সংখ্যা। তিনের সাথে আবার দুই যোগ করলে হবে ৫, আরেকটি বিজোড় সংখ্যা। এভাবে প্রতিবার ভ্যারিয়েবল এর মান দুই বাড়িয়ে দিলেই আমরা বিজোড় সংখ্যা গুলো পেতে পারি। উপরের প্রোগ্রামে সে কাজটিই করা হয়েছে। number = number + 2; দিয়ে প্রতিবার নাম্বার ভ্যারিয়েবলটির মান দুই করে বাড়িয়ে দেওয়া হয়েছে।</p>
<p>প্রথমে ভ্যারিয়েবলটির মান ছিল 1, int number = 1; এর কথা বলছি। এরপর লুপের ভেতরে ঢুকলো। এবং কন্ডিশন চেক করা হল। যেহেতু কন্ডিশন সত্য, তাই লুপের ভেতরের কোড গুলো রান করল। number টি প্রিন্ট করল। পরের লাইনে number ভ্যারিয়েবল টির মান দুই বাড়িয়ে দেওয়া হলো। এভাবে এক সময় যখন দেখল number ভ্যারিয়েবলটির মান 100 থেকে বেশি হয়ে গেলো, তখন লুপটি কাজ করা শেষ করল।</p>

<p><strong><em>উপরের প্রোগ্রামটিকে একটু মডিফাই করেই তো জোড় সংখ্যা গুলো বের করতে পারি তাই না? তাহলে তা করে ফেলুন। এরপর কমেন্টে আমাকে জানাতে পারেন।</em></strong></p>


 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3469">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিংঃ do - while</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>কিছু একটা কর, যতক্ষণ পর্যন্ত একটা কন্ডিশন সত্য হয়। এমন প্রোগ্রাম লিখতে আমরা do while ব্যবহার করি।<br />
do while লুপের সাধারণ ফরম হচ্ছেঃ</p>
<p><strong><em>do statement while (expression); </em></strong></p>
<p>expression বলতে একটা কন্ডিশন দেওয়া হয়। যতক্ষণ  পর্যন্ত এই কন্ডিশনটি সত্য হবে, ততক্ষন পর্যন্ত এই do while লুপটি চলবে এবং এই statement এক্সিকিউট হতে থাকবে। একটি স্টেটমেন্ট এক্সিকিউট করার জন্য আমাদের দ্বিতীয় ব্র্যকেট ব্যবহার করতে হবে না। কিন্তু যদি আমরা একের অধিক স্টেটমেন্ট এক্সিকিউট করতে চাই, তাহলে আমাদের দ্বিতীয় ব্র্যাকেট ব্যবহার করতে হবে। তখন লিখতে হবে এমন করেঃ</p>
<xmp>
do{
 statement 1;
 statement 2;
 statement 3;
....

} while (expression);

</xmp>
<p>ছোট্ট একটা প্রোগ্রাম লিখিঃ<br /></p>

<xmp>
#include <stdio.h>
int main ()
{
    int number  = 0;
    do {
        printf("%d \n", number);
        number++;
    } while (number <=9);
return 0;
}
</xmp>

<p>উপরের প্রোগ্রামে আমরা number নামে একটা ইন্টিজার ভ্যারিয়েবল নিয়েছি। যার প্রাথমিক মান হচ্ছে ০। এরপর আমরা do while লুপ লিখছি। do এর পর দ্বিতীয় ব্র্যাকেটের মধ্যে আমরা যে স্টেটমেন্ট গুলো এক্সিকিউট করতে হবে, সে গুলো লিখেছি। এরপর লিখছি while  (number <=9) এটা হচ্ছে কন্ডিশন। যতক্ষন পর্যন্ত এ কন্ডিশনটা সত্য হবে, ততক্ষণ পর্যন্ত ব্র্যাকেটের ভেতরের  {…} কোড গুলো এক্সিকিউট হবে। ব্র্যাকেটের ভেতরে আমরা প্রথমে নাম্বারটি প্রিন্ট করেছি। পরের লাইনে number++; দিয়ে নাম্বারটির মান এক করে বাড়িয়ে দিয়েছি। এরপর এক সময় number এর মান 10 হয়ে গেছে। তখন while (number <=9) এ এসে দেখল কন্ডিশনটি মিথ্যে হয়ে গেছে। মানে number  এর মান ৯ এর থেকে বড়, তখন আর do  ভেতরে আর ঢুকবে না এবং তার ভেতরের কোড গুলোও এক্সিকিউট করবে না।

উপরের প্রোগ্রামটি আমরা আরেকটু ছোট করে লিখতে পারে। একই ভাবে কাজ করবে। শুধু ব্র্যকেটটি সরিয়ে ফেলছি।</p>

<xmp> 
#include <stdio.h>
int main ()
{
    int number  = 0;
    do
    printf("%d \n", number++);
    while (number <=9);
return 0;
}
</xmp>

<p>আমরা যদি একটি মাত্র স্টেটম্যান্ট এক্সিকিউট করতে চাই, তাহলে আমাদের দ্বিতীয় ব্র্যকেট ব্যবহার না করলেও হবে।</p>
<p>do while ব্যবহার করে আমরা কিছু সংখ্যার গড় বের করব। প্রোগ্রামটি প্রথম ব্যবহারকারীকে জিজ্ঞেস করব, কয়টা সংখ্যার গড় ব্যবহার করতে চায়। এরপর এক এক করে সব গুলো সংখ্যা ইনপুট নিবে। তারপর গড় দেখাবে।</p>

<xmp> 
#include <stdio.h>
int main ()
{
    int total_no, count = 1;
    float number, average, sum =0;

    printf("How many numbers? ");
    scanf("%d", &total_no);


    do{

        printf("Enter number %d : ", count);
        scanf("%f", &number);
        sum +=number;
        count++;

    }while (count <=total_no);

    average = sum / total_no;
    printf("Average is : %f\n", average);

return 0;
}
</xmp>

<p>আমরা অনেক গুলো ভ্যরিয়েবল ডিক্লেয়ার করেছি। total_no  হচ্ছে কয়েটা নাম্বারের গড় বের করব, তার জন্য। এরপর আমরা do while লুপে প্রবেশ করেছি। লুপ ততক্ষণই চলবে যতক্ষণ না পর্যন্ত আমাদের সব গুলো নাম্বার ইনপুট নেওয়া হয়। তার জন্য আমরা একটা count ভ্যারিয়েবল নিয়েছি। যার প্রথম মান হচ্ছে ১। এর পর প্রতিবার আমরা একটা সংখ্যা ইনপুট নিব, একবার করে এই count এর মান বাড়িয়ে দিব। </p>
<p>number নামক ভ্যারিয়েবল দিয়ে আমরা এরপর প্রতিটা সংখ্যা ইনপুট নিচ্ছি। ইনপুট নিয়ে সেগুলো সব যোগ করছি। ছোট্ট একটা লাইন দিয়ে। sum +=number; যার মানে হচ্ছে sum = sum + number; </p>
<p>যখন দেখেছি count এর মান total_no এর থেকে বড় হয়ে গেছে, তার মানে হচ্ছে আমাদের সকল সংখ্যা ইনপুট নেওয়া হয়ে গেছে। তাই আমরা do while থেকে বের হয়ে গিয়েছি। এরপর গড় বের করেছি। তারপর প্রিন্ট।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3470">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিংঃ for-লুপ</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>লুপিং এর কাজে সবছেয়ে বেশি ব্যবহৃত হয় for loop. এ for loop এর তিনটি অংশ রয়েছে। তার আগে আমরা দেখেনি for loop সাধারন ব্যবহার নিয়ম।</p>
<p><code><strong><em>for(exprission1</em></strong><strong><em>;</em></strong><strong><em>Exprission2</em></strong><strong><em>;</em></strong><strong><em>Expression3)Statement</em></strong></code></p>
<p>বিদ্রঃ এখানে প্রত্যেকটি Expression ; (সেমিকোলন) দিয়ে আলাদা করে দিতে হবে।</p>
<p>এখানে প্রথম exprission1  হচ্ছে for loop এর প্রথম অংশ। এটি দ্বারা একটি প্রাথমিক মান দেওয়া হয় । যাকে বলা হয় initial অংশ।  এটি পুরো লুপিং প্রক্রিয়াকে নিয়ন্ত্রন করে।</p>
<p>দ্বিতীয় অংশটি অর্থাৎ Exprission2 দ্বারা  একটি শর্ত দেওয়া হয়। লুপটি কতক্ষন পর্যন্ত চলবে তা এটি নির্নয় করে। Exprission2 তে সাধারনত একটি logical expression থাকে যা শুধু সত্য মিথ্যে বুঝতে পারে। যদি সত্য হয় তাহলে 1 রিটার্ন করে আর যদি মিথ্যে হয় তাহলে 0 রিটার্ন করে।  এটি যদি 0 ছাড়া অন্য কোন মান রিটার্ন করে তাহলে লুপটি চলবে, আর যদি 0 রিটার্ন করে তাহলে লুপটি আর চলবে না।</p>
<p>Expression3 কাজ হচ্ছে আমারা প্রথমে যে প্রাথমিক মান নিলাম তাকে আমাদের ইচ্ছে মত মডিফাই করা। এটি প্রত্যেক লুপের শেষ ধাপে কাজ করে।</p>
<p>আর আগেই বলছি লুপটি ততক্ষনই চলবে যতক্ষন পর্যন্ত Exprission2 মিথ্যে বা  0 রিটার্ন না করে।</p>
<p>For loop সম্পর্কে আমরা এতক্ষন অনেক কিছু জানলাম, এবার প্রোগ্রামে এটাকে কিভাবে ব্যবহার করব তা দেখি। তার জন্য একটি প্রোগ্রাম লিখি যা 1 থেকে 10 পর্যন্ত সংখা গুলো প্রিন্ট করবে।<br />
আপনাদের জন্য নিচের প্রোগ্রামটি। এটার আউটপুট কি হবে কিভাবে হবে তা বের করুন।<br />

<xmp>
#include<stdio.h>
int main(void)
{
int i;
for(i=0;i<=10;i++)
    printf("%d\n",i);
}
</xmp>

এর আউট পুট হচ্ছেঃ <code> ০ 1 2 3 4 5 6 7 8 9 10</code> এখানে আমরা একটি integer variable নিয়েছি। for loop এর প্রথম Expression এ আমরা এর প্রাথমিক মান নিলাম ০. প্রাথমিক মানটি for loop এর দ্বিতীয় অংশ অর্থাৎ logical অংশ দ্বারা যাচাই না হয়েই for লুপের ভেতরে থাকা স্টেটমেন্টটি এক্সিকিউট করবে। এবং প্রথম Expression কাজ শেষ হয়ে যাবে। এর আর কোন কাজ নেই।</p>
<p>Print করার পর এবার তৃতীয় অংশ অর্থাৎ Exprission3 এখানে i++ অংশ দ্বারা মডিফাই হবে। আমরা জানি i++ এর মানে হচ্ছে i = i+1 সুতরাং এখানে i এর মান এক বাড়বে এবং ০ থেকে 1 হবে। এবার দ্বিতীয় অংশ Expression2 এখানে এসে i<=10 অংশ দ্বারা লজিক্যাল যাচাই হবে। এখানে যাচাই করবে যে i এর মান 10 বা 10 থেকে ছোট কিনা। যেহেতু এখন i এর মান ১০ থেকে ছোট তাই লুপটা আবার চলবে। এবং দ্বিতীয় বার এসে 1 প্রিন্ট করবে।  আবার Exprission3 তে এসে মডিফাই হবে। আগের লুপ থেকে i এর মান পেয়েছি 1 এখন আবার 1 এর সাথে এক বেড়ে 2 হবে ( এ অংশ i++ দ্বারা) ।</p>
<p>আবার দ্বিতীয় অংশ i<=10 অংশ দ্বারা লজিক্যাল যাচাই হবে। যেহেতু 2,  10 থেকে ছোট তাই আবার 2 প্রিন্ট করবে। এভাবে প্রত্যেক ধাপ শেষ করবে। যখন i এর মান বেড়ে 11 হয়ে যাবে তখন আর লুপ চলবে না। এবং আমাদের প্রোগ্রামটি শেষ হবে। আচ্ছা, আরেকটা প্রোগ্রাম লিখি। ছোট কালে কোন দুষ্টুমি করলে যে আমাদের শাস্তি দেওয়া হতো একশ বার লিখতে, আমি আর দুষ্টুমি করব না। আমরা এবার তা লিখব প্রোগ্রাম লিখে। এবং for লুপ ব্যবহার করে। 
</p>
<xmp>
#include<stdio.h>
int main(void)
{
int i;
for(i=0;i<=100;i++)
    printf("ami r dustumi korbo na. \n");
return 0;
}
</xmp>

<p>এখানে আগের প্রোগ্রামের থেকে একটু পার্থক্য হচ্ছে আগে আমরা i এর মান প্রিন্ট করেছি। এখানে আমরা একটা লাইন প্রিন্ট করেছি &#8220;ami r dustumi korbo na.&#8221; for লুপ এর ভেতরের Exprission2 তে লিখেছি i<=100। মানে i এর মান যতক্ষণ না পর্যন্ত ১০০ হচ্ছে, ততক্ষণ পর্যন্ত এই লুপটি চলবে। Exprission3 তে i এর মান আমরা প্রতিবার ১ করে বাড়িয়ে দিয়েছি।<br />
এবার আমরা আরেকটি প্রোগ্রাম লিখি। এবার এক থেকে ৫০ পর্যন্ত বেজোড় সংখ্যা গুলো বের করার একটা প্রোগ্রাম লিখি।<br />

<xmp>
#include <stdio.h>
int main(void)
{
int i;
for(i=0;i<=50;i++)
    {
    if(i%2==1)
        printf("%d\n",i);
    }
return 0;    
}
</xmp>

আগের প্রথম প্রোগ্রামের মতই i এর মান আমরা প্রিন্ট করেছি। তবে একটা কন্ডিশন দিয়েছি এখানে। for লুপের ভেতর প্রতিবার ঢুকবে। ঢুকার পর if দিয়ে একটা কন্ডিশন চেক করবে। if(i%2==1) মানে হচ্চে i কে দুই দ্বারা ভাগ করলে ভাগ শেষ যদি ১ থাকে, তাহলে if কন্ডিশনের ভেতরের স্টেটমেন্ট printf(&#8220;%dn&#8221;,i); দিয়ে i এর মান প্রিন্ট হবে। আর না হলে কিছুই হবে না। এখানে কি করছি কি, একটা লুপের ভেতর আরেকটা লুপ ব্যবহার করেছি।</p>
<p>আমরা ইচ্ছে করলে এমন একটা লুপের ভেতর আরেকটা, আরেকটা ভেতর আরেকটা এমন ইচ্ছে মত ব্যবহার করতে পারি। যেমন আমরা এবার একটা for লুপের ভেতর আরেকটা for লুপ ব্যবহার করব। তবে তার আগে উপরের প্রোগ্রামটি আরো সহজে কিভাবে লেখা যায়, তা দেখি। আমরা ইচ্ছে করলে ১ থেকে ৫০ পর্যন বেজোড় সংখ্যা গুলো নিচের মত করেও বের করতে পারিঃ</p>


<xmp>
#include<stdio.h>
int main(void)
{
int i;
for(i=1;i<=50;i=i+2)
    printf("%d\n",i);

return 0;
}
</xmp>

<p>এখানে করছি কি i এর প্রথম মান ধরে নিয়েছি ১। এক একটা বিজোড় সংখ্যা। তা প্রিন্ট করবে। এরপর ১ এর সাথে ২ যোগ করে দিলেই তো হবে ৩, তা বিজোড় সংখ্যা। তা প্রিন্ট করবে। এরপর ৩ এর সাথে ২ যোগ করে দিলে হবে ৫, তা বিজোড় সংখ্যা। তা প্রিন্ট করবে। আমরা লুপের Expression3 তে লিখছি i=i+2। লুপের Expression2 তে কন্ডিশন দিয়েছি i<=50। মানে যতক্ষণ না পর্যন্ত i এর মান ৫০ এর বেশি হবে, ততক্ষন পর্যন্ত লুপটি চলবে।।</p>

<p>এবার একটা for লুপের ভেতরে আরেকটা for লুপ ব্যবহার করে একটা প্রোগ্রাম লিখিঃ<br />

<xmp>
#include<stdio.h>
int main(void){
int i, j;

for(i=0;i<=5;i++){
    for (j=0;j<=i;j++){
        printf("%d ", j);
    }
    printf("\n");
  }

return 0;
}
</xmp>

এখানে আমরা দুইটা ভ্যারিয়েবল নিয়েছি। i এবং j. প্রথম for লুপের ভেতর i এর ইনিশিয়াল মান দিয়েছি ০, কন্ডিশন দিয়েছি i<=5 এবং i এর মান 1 করে বাড়িয়েছি। মানে হচ্ছে প্রথম for লুপটি ৫ বার এক্সিকিউট হবে। প্রোগ্রামটি আউটপুট দিবঃ  </p>

<xmp>
0
0 1
0 1 2
0 1 2 3
0 1 2 3 4
0 1 2 3 4 5
</xmp>
<p>  দ্বিতীয় ফর লুপে j=0 দিয়ে ইনিশিয়াল মান দিয়েছি ০, এরপর j<=i দিয়ে কন্ডিশন দিয়েছি। এবং শেষে j++ দিয়ে j এর মান বাড়িয়েছি। কন্ডিশন অনুযায়ী দ্বিতীয় ফরলুপটি কতবার এক্সিকিউট হবে তা নির্ভর করবে প্রথম ফর লুপের উপর। যেমন প্রথম বার i এর মান ০। তাই প্রথমবার দ্বিতীয় ফর লুপ চলবে একবার। দ্বিতীয় বার i এর মান ১, তাই দ্বিতীয় বার দ্বিতীয় লুপ চলবে দুই বার। তৃতীয় বার দ্বিতীয় ফর লুপ চলবে ৩ বার। এবার পঞ্চম বার দ্বিতীয় লুপ চলবে ৫বার। প্রথম বার দ্বিতীয় লুপ প্রিন্ট করবে ০, দ্বিতীয়বার প্রিন্ট করবে 0 1. তৃতীয় বার 0 1 2. এভাবে পঞ্চম বার প্রিন্ট করবে 0 1 2 3 4 5. এখন আমরা যদি প্রথম ফর লুপের কন্ডিশন পরিবর্তন করে দশ করে দি, তাহলে আউটপুট দিবেঃ</p>
<p><img  src="images/nested-for-demo.png" />  </p>
<p>do while দিয়ে আমরা কয়েকটা সংখ্যার গড় বের করার প্রোগ্রাম লিখেছি এর আগে। এবার আমরা তা for লুপ ব্যবহার করে লিখবঃ</p>

<xmp>
#include <stdio.h>
int main ()
{
    int total_no, count;
    float number, average, sum =0;

    printf("How many numbers? ");
    scanf("%d", &total_no);

    for(count = 1; count <= total_no; count++){
        printf("Enter number %d : ", count);
        scanf("%f", &number);
        sum +=number;
    }

    average = sum / total_no;
    printf("Average is : %f\n", average);

return 0;
}
 </xmp>


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3471">

	<div data-role="header">	
	
		<h1>switch case</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>একটা ভ্যালু এর উপর নির্ভর করে অনেক গুলো স্টেটম্যান্ট থেকে একটা স্টেটম্যান্ট এক্সিকিউট করার জন্য switch case ব্যবহার করা হয়। switch case  সাধারণত নিচের মত করে লেখা হয়ঃ</p>

 <xmp>
 switch ( variable ) {
    case expression 1:
        statement;
        break;
    case expression 2:
        statement;
        break;
    case expression 3:
        statement;
        break;
    default:
        statement;
        break;

}
</xmp>

<p>এখানে যদি switch ( variable ) এর variable  টির মান expression 1 এর সাথে মিলে, তাহলে case expression 1 এর  statement এক্সিকিউট হবে। যদি variable  টির মান expression 2 এর সাথে মিলে, তাহলে case expression 2 এর  statement এক্সিকিউট হবে। যদি variable  টির মান expression 3 এর সাথে মিলে, তাহলে case expression 3 এর  statement এক্সিকিউট হবে। যদি কোনটির সাথেই না মিলে, তাহলে default এর  statement টি এক্সিকিউট হবে। এখানে যত ইচ্ছে তত গুলো case যুক্ত করা যাবে।  আর case এর স্টেটম্যান্ট শেষে break; যুক্ত করতে হয়। break; মানে হচ্ছে আমাদের কাজ শেষ, এবার switch case থেকে বের হতে পারি। break; টা খুবি গুরুত্ত্বপূর্ণ।</p>
<p>এখনো একটু জটিল মনে হতে পারে বিষয়টা, আমরা একটা উদাহরন দেখলে অনেক সহজ হয়ে যাবে এই switch case স্টেটম্যান্টটি। আমরা একটা প্রোগ্রাম লিখব এমন, যেখানে যদি আমরা r ইনপুট দি, তাহলে লেখা উঠবে You select Red, যদি w ইনপুট দি, তাহলে লেখা উঠবে You select White. যদি b ইনপুট দি, তাহলে লেখা উঠবে You select Black. আর প্রোগ্রামটা লিখব আমরা switch case ব্যবহার করে।  </p>

<xmp>
#include <stdio.h>
int main ()
{
char colorCode;
printf("Enter first word of Red, White or Black: \n");
scanf("%c", &colorCode);


switch ( colorCode ) {
    case 'r' :
    printf("You select Red.");
    break;

    case 'w':
    printf("You select White.");
    break;

    case 'b':
    printf("You select Black.");
    break;

    default:
    printf("Wrong choose!");
    break;
}
return 0;
}
</xmp>

<p>উপরের প্রোগ্রামটি রান করি, তারপর r, w, b এ তিনটার মধ্যে যে কোন একটা ইনপুট দিলে ঐ কালারটা দেখবে। আর যদি আমরা অন্য কোন কারেকটার ইনপুট দি, তাহলে লেখা উঠবে Wrong choose!।<br />
switch case এর switch ( colorFirsWord ) এর ভেতরে যে ভ্যারিয়েবলটি রয়েছে, তার মান যদি case &#8216;r&#8217; এর সাথে মিলে, মানে colorFirsWord এর মান r হয়, তাহলে প্রোগ্রামটি এ স্টেটম্যান্টটি এক্সিকিউট করবেঃ printf(&#8220;You select Red.&#8221;); এরপরের স্টেটম্যান্ট হচ্ছে break; মানে হচ্ছে আমরা যে কাজ করার জন্য switch case এর ভেতরে প্রবেশ করেছি, তা শেষ হয়েছে। switch case থেকে এবার আমরা বের হতে পারি। break দিয়ে switch case ঐখানেই বন্ধ করে দেওয়া হয়।</p>
<p>একই ভাবে যদি আমরা w ইনপুট দি, তাহলে case &#8216;r&#8217; এর সাথে মিলিয়ে দেখবে। যেহেতু আমরা w ইনপুট দিয়েছি, প্রথম case এর সাথে মিলে না। পরের case দেখবে। পরের case এ এসে দেখবে case &#8216;w&#8217; তে ইনপুটির সাথে মিল পেয়েছে, তাই এর পরে থাকা স্টেটম্যান্টটি এক্সিকিউট করবে। printf(&#8220;You select White.&#8221;); এবং এর পর break দিয়ে switch case থেকে বের হবে।</p>
<p>একই ভাবে আমরা যদি b ইনপুট দি, তাহলে উপরের দুইটা case এ কোন মিল পাবে না, তাই ঐ case গুলোর স্টেটম্যান্ট গুলোও এক্সিকিউট হবে না। শুধু মাত্র case &#8216;b&#8217; এর স্টেটম্যান্ট গুলো এক্সিকিউট হবে।</p>
<p>যদি আমরা অন্য কোন কারেকটার ইনপুট দি, তাহলে তার জন্য রয়েছে ডিফল্ট ভ্যালু। তখন লেখা উঠবে Wrong choose!</p>
<p>বিদ্রঃ switch ( colorCode ) এর এখানে যে কোন Expression আমরা লিখতে পারি। এমন একটা উদাহরন আমরা দেখব। আবার case এ আমরা একের অধিক স্টেটম্যান্ট লিখতে পারব। তার উদাহরণ একটু পরই দেখব।</p>
<p>উপরের প্রোগ্রামটিতে আমরা যদি বড় হাতে R, W বা B ইনপুট দি, তাহলে লেখা উঠবে Wrong choose!। এখন আমরা উপরের প্রোগ্রামটিকে আরেকটু মডিফাই করব, যেন ছোট বা বড় হাতে colorCode ইনপুট দিলে উভয় ক্ষেত্রেই আমাদের সঠিক আউটপুট দেয়।<br />
 </p>
<xmp>
#include <stdio.h>
int main ()
{
char colorCode;
printf("Enter first word of Red, White or Black: \n");
scanf("%c", &colorCode);


switch ( colorCode ) {
    case 'r' :
    case 'R' :
    printf("You select Red.");
    break;

    case 'w':
    case 'W' :
    printf("You select White.");
    break;

    case 'b':
    case 'B' :
    printf("You select Black.");
    break;

    default:
    printf("Wrong choose!");
    break;
}
return 0;
}
</xmp>

<p>এখানে আমরা লক্ষ্য করলে দেখব আমরা এখন break এর ব্যবহার ছাড়া এক সাথে দুই বার case ব্যবহার করেছি। যেমনঃ</p>
<p>case &#8216;r&#8217; :<br />
 case &#8216;R&#8217; :</p>
<p>এভাবে break ছাড়া একের অধিক case লিখলে সে গুলো OR অপারেশনের মত কাজ করে। একটা সত্য হলে ঐ case গুলোর পরের Expression গুলো এক্সিকিউট হবে। এবং break পাওয়া পর্যন্ত অপেক্ষা করবে।</p>
<p>switch case এর ভেতরে যে কোন কোডই রান করানো যায়, লুপ চালানো, ফাংশান কল করা সহ সব কিছু। প্রথমে একটা প্রোগ্রাম লিখব, যেখানে switch case এর ভেতরে আমরা একবার for লুপ ব্যবহার করব, একবার while লুপ ব্যবহার করব। এটা বুঝানোর জন্য যে আমরা ইচ্ছে করলে যে কোন কোডই রান করাতে পারি switch case এর মধ্যেঃ</p>


#include <stdio.h>
int main ()
{
int code;
int i = 0;
printf("Enter 1 to print even integers or enter 2 to print odd integers: ");
scanf("%d", &code);


switch ( code ) {
    case 1 :
        while(i<=100){
            printf("%d \n", i);
            i=i+2;
        }
    break;


    case 2 :
         for(i =1; i<=100; i=i+2)
                printf("%d \n", i);

    break;


    default:
    printf("Wrong choose!");
    break;
}
return 0;
}


<p>প্রোগ্রামটা আমাদের 1 অথবা 2 ইনপুট দিতে বলবে। 1 ইনপুট দিলে ১ থেকে ১০০ পর্যন্ত বেজোড় সংখ্যা গুলো প্রিন্ট করবে। আর 2 ইনপুট দিলে ১ থেকে ১০০ পর্যন্ত জোড় সংখ্যা গুলো প্রিন্ট করবে।</p>
<p>আমরা ইচ্ছে করলে switch case এর ভেতর থেকে ফাংশন ও কল করতে পারি। নিচের প্রোগ্রামটি দেখিঃ</p>


<xmp>
#include <stdio.h>
int main ()
{
    void playGame(){
       printf("You choose to Play the game.");
        }
    void closeGame(){
       printf("You choose to Close the game.");
        }


int code;

printf("Enter 1 to play the Game.\nEnter 2 to close the Game :");
scanf("%d", &code);


switch ( code ) {
    case 1 :
        playGame();
        break;


    case 2 :
        closeGame();
        break;


    default:
    printf("Wrong choose!");
    break;
}
return 0;
}
</xmp>

<p>আমরা দুইটা ফাংশন তৈরি করেছি, playGame() এবং closeGame()। ব্যবহারকারী 1 ইনপুট দিলে playGame() ফাংশনটি কল হবে, এবং 2 ইনপুট দিলে closeGame() ফাংশন কল হবে&#8230; এভাবে নিজের মত করে নিজের ক্রিয়েটিভিটি ব্যবহার করে আমরা প্রয়োজন মত আমাদের প্রোগ্রামে switch case ব্যবহার করতে পারি। শুভ প্রোগ্রামিং </p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3472">

	<div data-role="header">	
	
		<h1>সি তে ফাংশন</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>প্রোগ্রামারদের ম্যাজিক হচ্ছে ফাংশন। এখন আবার আপনার মনে হতে পারে এটা আবার কি? তাই না। মনে করেন আপনি একটা ম্যাজিক শোতে গিয়েছেন। আপনি এখন একটা ম্যাজিক দেখাবেন যেখানে একটা ছেড়া সুতোকে ফু দিলে তা জোড়ালেগে যাবে। এমনই তো দেখেন তাই না? এই ফু টাই হচ্ছে ফাংশন।</p>
<p>তাহলে আমরা এটা কিভাবে লিখব প্রোগ্রামে তা দেখিঃ</p>
<p>সম্পুর্ন সুতো= ফু(ছেড়া সুতো);</p>
<p>অর্থাৎ যাকে ফু দিবেন তা ব্র্যাকেটে লিখতে হয় তাহলে ফু দেওয়ার ফলে কি হয় তা পাওয়া যায়।</p>
<p>এখন ফু শুধু মাত্র ছেড়া সুতো উপর কাজ করে। এখন যদি আপনি ছেড়া সুতোর পরিবর্তে অন্য কিছু যেমন একটা কাগজকে ফু দেন তা কিন্তু টাকাতে পরিনত হবে না। তার জন্য কিছু মন্ত্র পড়তে হবে। এখানে মন্ত্রটা হচ্ছে ফাংশসন।</p>
<p>টাকা = ফু(কাগজ);</p>
<p>কাগজের উপর ফু দিলে তা টাকাতে পরিনত হচ্ছে তাই না?<br />
ফাংশনটা ও একই রকম। এই ফু বা মন্ত্র এর মত। এখন আপনাকে বুঝতে হয় কোথায় কি ব্যবহার করতে হবে। অনেক হাবি জাবি বকা হয়ে গেছে এখন দেখি কিভাবে তা আমরা কাজে লাগাবো।</p>
<p>আমরা দুটি সংখা যোগ করতে চাই।</p>
<p>তার জন্য আমাদের যোগ নামে একটা ফাংশন লাগবে।</p>
<p>যোগফল = যোগ(সংখ্যা১, সংখ্যা২);</p>
<p>এখন আপনি হয়তো আমাকে দেখে হাসতে পারেন এত ভেজাল করার কি দরকার। আমি তো এমনিতেই দুটি সংখ্যার মাজে + চিহ্ন দিয়ে যোগ ফল পেতে পারি, মাঝখানে ফাংশন নামক এ বস্তুটা নিয়ে আসার কি দরকার?<br />
আচ্ছা, এটা আমাদের বার বার যোগ করা থেকে বাঁচিয়ে দিব। শুধু মাত্র যোগ ফাংশনটাকে ডাকলেই আমাদের কাজ করে দিব।</p>
<p>আচ্ছা, ফাংশন কি তা আগে জানি। <strong>ফাংশন হচ্ছে পুনরায় ব্যবহার যোগ্য কোড ব্লক। যা একটি নির্দিষ্ট কাজ করতে পারে। ফাংশন ভালো ভাবে জানলেই প্রোগ্রামিং এর একটা বিশাল অংশ শেখা শেষ হয়ে যায়। তা জানলেই নিজের ইচ্ছে মত কোড লেখা যায়। সকল প্রোগ্রামিং ল্যাঙ্গুয়েজ এ ফাংশন লেখার ধরন প্রায় একই।  আমি সি প্রোগ্রামিং দিয়ে উদাহরন দিচ্ছি। </strong><br />
একটা ফাংশন নিচের মত করে লেখা হয়ঃ</p>
<xmp>

Function_Data_Type Function_Name (Parameters){

....
return value;

}

</xmp>
<ul>
<li>Function_Data_Type হচ্ছে ফাংশনটি কি ধরনের ডেটা রিটার্ন করবে তা। যেমন int, char, float, double ইত্যাদি।</li>
<li>ফাংশানের তো একটা নাম থাকতে হবে তাই না? যে নাম দিয়ে ফাংশনটিকে ডাকতে হবে।  Function_Name হচ্ছে ফাংশানের নাম।</li>
<li>Parameters হচ্ছে ফাংশন দিয়ে কি কি ডেটা পাস করবে।  এখানে এক বা একাদিক Parameter পাস করা যেতে পারে। কোন কোন ফাংশানে কোন Parameter নাও থাকতে পারে।  এটা নির্ভর করে কি ধরনের ফাংশন লিখা হচ্ছে তার উপর। একের অধিক Parameter থাকলে তাদেরকে কমা দিয়ে লিখতে হয়।</li>
<li>কাজ শেষে ফাংশনটি কি রিটার্ন করবে তাই return দিয়ে  পাস করা হয়।</li>
</ul>
<p>নিচের ছবিটি দেখি। এখানে যোগ করার একটি ফাংশন এবং এর ভিবিন্ন অংশ দেখানো হয়েছেঃ</p>
<p><a href="images/function-add.jpg" rel="lightbox[3472]" title="function add"><img class="aligncenter  wp-image-1102" src="images/function-add.jpg" alt="function add" width="578" height="322" srcset="images/function-add-300x167.jpg 300w, images/function-add-1024x571.jpg 1024w, images/function-add.jpg 1205w" sizes="(max-width: 578px) 100vw, 578px" /></a></p>
<p style="text-align: left;">আমরা ছোট্ট একটা প্রোগ্রাম লিখে ফেলিঃ</p>
<xmp>
#include <stdio.h>
int add(int a, int b){

int sum = a+b;
return sum;
}
int main()
{
int x, y , result;
scanf("%d", &x);
scanf("%d", &y);
result = add(x,y);
printf("Result is: %d", result);
 return 0;
}
</xmp>
<p>#include <stdio.h> এর পরই আমরা ফাংশনটি লিখছি। main ফাংশন এর আগে। ফাংশনটি কল কছি add(x,y) দিয়ে। যার মধ্যে দুটি প্যারামিটার পাস করেছি। একটা x আরেকটা y, যে গুলো আমরা scanf ফাংশন দিয়ে ইনপুট হিসেবে নিয়েছি। এর ফলে আমাদের প্রোগ্রামটি main থেকে বের হয়ে add ফাংশানের ভেতরে যাবে। গিয়ে কিছু কাজ কমপ্লিট করবে। এবং ফাংশানের ভেতরের কাজ সম্পুর্ন হলে আবার main এ ফিরে আসবে।<br />
এখন ফাংশানে কি করছে জানেন? int a, int b নামক যে ভ্যারিয়েবল লিখছি ফাংশানের argument এ, প্রথম প্যারামিটার মানে x assign হবে a তে। এবং দ্বিতীয়টা মানে y assign হবে b তে। তারপর ফাংশনটি sum নামক ইন্টিজার ভ্যারিয়েবলে a+b এর মান রাখবে। return sum দিয়ে ঐ sum টা রিটার্ন করবে। এবং আমাদের main প্রোগ্রামে ফিরে আসবে। আবার ফাংশানে রিটার্ন করা ভ্যালুটা result নামক ভ্যারিয়েবলে এসাইন করবে।<br />
ছোট্ট একটা যোগের জন্য আসলেই আমরা অনেক ভেজাল করে ফেলছি। তবে এখন আমরা ফাংশন কি তা জানি, কিভাবে কাজ করে তাও জানি।</p>
<p>এবার আরো সহজ একটা ফাংশন লিখি।</p>
<xmp>

#include <stdio.h>
void callme(){
printf("You call me form Main n");
}
int main()
{
callme();
return 0;
}

&nbsp;

</xmp>
<p>এখানে আমরা callme নামক একটা ফাংশন লিখছি, যা কিছুই রিটার্ন করবে না। এ জন্য ফাংশানের Data Type লিখছি void। আচ্ছা, main থেকে যখন আমরা ফাংশনটিকে কল করছি  callme(); দিয়ে তখন ফাংশানের ভেতর গিয়ে দেখে You call me form Main লেখাটি প্রিন্ট করতে। প্রোগ্রামটি তাই করল। এবং callme ফাংশন থেকে বের হয়ে আবার main এ আসল। তারপর দেখল আর কোন কাজ নেই। তাই কি করল? প্রোগ্রামটি শেষ করল।</p>
<p>আমরা আরেকটু কঠিন একটা ফাংশন লিখে ফেলতে পারি না?</p>
<p>আমি কঠিন বলছি তাই বলে মোটেও কঠিন হবে না। এবার আমরা দুটি সংখ্যার মধে বড় সংখ্যাটা বের করার ফাংশন লিখব। তখন কি হবে জানেন? আচ্ছা আগে কোডটি লিখে ফেলিঃ</p>
<xmp>

#include <stdio.h>
int max(int a, int b){

int maximum = (a>;=b) ? a : b ;
return maximum;
}
int main()
{
int x, y , result;
scanf("%d", &x);
scanf("%d", &y);
result = max(x,y);
printf("max is: %d", result);
 return 0;
}

</xmp>
<p>এখানে আমরা max নামে একটা ফাংশন লিখছি। বাকি অংশ আগের মতই। ফাংশানের ভেতর Conditional Operator (?:) ব্যবহার করছি।  Conditional Operator সম্পর্কে জানতে লিঙ্কে ক্লিক করে লেখাটি পড়ুন।  এর আগে আমরা দুটি সংখ্যা যোগ করছি ফাংশানের ভেতর। এবার দুটি সংখ্যার মধে বড় সংখ্যাটা ফাংশন রিটার্ন করছে। এবং পরে তা আমরা প্রিন্ট করছি।</p>
<p>আচ্ছা, ফাংশন লিখলেই যে রিটার্ন করতে হবে এমন না। ফাংশন কোন কিছু রিটার্ন নাও করতে পারেন। সে ধরনের ফাংশানের Function_Data_Type লিখতে হয় void. আরেকটা ছোট্ট প্রোগ্রাম লিখে ফেলি, কি বলেন?</p>
<xmp>

#include <stdio.h>

void max(int a, int b){
int maximum = (a>;=b) ? a : b ;
printf("max is: %d", maximum);
}

int main()
{
int x, y;
scanf("%d", &x);
scanf("%d", &y);
max(x,y);
return 0;
}

</xmp>
<p>এখানে কি করছি জানেন, আমরা ফাংশনটিকে কল করছি। ফাংশানের ভেতরই বড় ছোট নির্নয় করেছি। ফাংশানের ভেতরই প্রিন্ট করছি। তারপর ফাংশন থেকে বের হয়ে গেছি। মেইন প্রোগ্রামে এসে দেখি আর কোন কাজ বাকি নেই। তাই পোগ্রামটি শেষ হয়েছে।</p>
<p>Factorial কি তা তো আমরা জানি, তাই না? একটি পূর্ণসংখ্যা ও শূন্য থেকে বড় ও সংখ্যাটি থেকে ছোট সকল পূর্ণসংখ্যার গুনফল হচ্ছে ফ্যাক্টোরিয়াল। n পূর্ণসংখ্যা হয়, তাহলে n এর ফ্যাক্টোরিয়াল প্রকাশ করা হয় এভাবেঃ n! যেমন 5! এর মান হবে 120</p>
<p><a href="images/five-factorial.png" rel="lightbox[3472]" title="five factorial"><img class="aligncenter size-full wp-image-1129" src="images/five-factorial.png" alt="five factorial" width="248" height="15" /></a></p>
<p>একটা পূর্ণসংখ্যার Factorial বের করার একটি প্রোগ্রাম লিখিঃ</p>
<xmp>
#include <stdio.h>

long int factorial(int n){
int i;
long int result =1;
if(n>;1){
for(i=2; i<=n; i++)
result = result*i;
}
return result ;
}

int main()
{
int a;
scanf("%d", &a);
printf("Factorial of n is : %d", factorial(a));
return 0;
}
</xmp>
<p>এখানে আমরা একটি ফাংশন লিখছি যা ফ্যাক্টোরিয়াল বের করতে পারে। প্যারামিটার হিসেবে আমাদের রয়েছে একটি argument. প্রোগ্রামটি রান করে এর পর http://en.wikipedia.org/wiki/Factorial  এ গিয়ে ভিবিন্ন সংখ্যার ফ্যাক্টোরিয়াল এর সাথে মিলিয়ে দেখুন আমাদের প্রোগ্রাম কাজ করে কিনা ঠিক মত।<br />
বড় সংখ্যার জন্য প্রোগ্রামটি ঠিক মত কাজ করবে না। কেন করবে না? বের করার দ্বায়িত্ব আপনার </p>
<p>আচ্ছা, আমরা এতক্ষন যে ফাংশন গুলো লিখছি তা main এর আগে লিখছি। আমরা ইচ্ছে করলে main এর পরেও লিখতে পারি। তবে তার জন্য main ফাংশন এর আগে তাকে ডিক্লেয়ার করতে হবে। যাকে বলে Function Prototype.</p>
<xmp>

#include <stdio.h>

void checkprime(int num);

int main()
{
int a;
scanf("%d", &a);
checkprime(a);
return 0;
}

void checkprime(int num){
 int i,count=0;
 for(i=2;i<=num/2;i++){
 if(num%i==0){
 count++;
 break;
 }
 }
 if(count==0 && num!= 1)
 printf("%d is a prime number",num);
 else
 printf("%d is not a prime number",num);
}

</xmp>
<p>এখানে আমরা প্রাইম নাম্বার চেক করার একটা প্রোগ্রাম লিখছি। এর মধ্যে আমরা  checkprime নামক একটা ফাংশন লিখছি যা আমরা main এর পর লিখছি। checkprime নামক যে একটা ফাংশন রয়েছে আমাদের প্রোগ্রামের main এর পর তা আমাদের আগে জানিয়ে দিতে হবে। সে জন্যই Function Prototype. এ জন্য মেইন এর আগে আমাদের ফাংশন প্রোটোটাইপ লিখতে হয়। যেমন আমাদের ফাংশানের প্রোটোটাইপ হচ্ছেঃ void checkprime(int num);</p>
<p>অর্থাৎ Function Prototype লিখতে হবে এমনঃ</p>
<xmp>Function_Data_Type Function_Name (Parameters);</xmp>
<p>যদিও অনেক কম্পাইলারে Function Prototype লিখতে হয় না।</p>
<p>এই হলো ফাংশন। অনেক সহজ জিনিস, তাই না? আগেই ও বলছি একবার আবার বলি। প্রোগ্রামিং শেখার জন্য অল্প কয়েকটি জিনিস বুঝলেই হয়। ভ্যারিয়েবল, লুপ, ফাংশন আর এরে। এগুলো দিয়েই যে কোন প্রোগ্রাম লিখে ফেলা যায়। দরকার একটু প্র্যাকটিস। আশা করি তা নিয়মিত করবেন।</p>
<p>সবার জন্য শুভ কামনা। শুভ প্রোগ্রামিং।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3473">

	<div data-role="header">	
	
		<h1>C Array - অ্যারে</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>একটা প্রোগ্রামের চিন্তা করি, যেটায় ইউজার থেকে দুইটা নাম্বার নিয়ে যোগ করে তা রিটার্ন / প্রিন্ট করবে বা কনসোলে দেখাবে।</p>
<p>সহজেই আপনি প্রোগ্রামটা লিখে ফেলতে পারবেন তাই না? দুটি ভ্যারিয়েবল নিলাম, তারপর তা যোগ করে প্রিন্ট করলাম। শেষ।<br />
যেমনঃ</p>

<xmp>
#include <stdio.h>
int main(){

int x, y;

    printf("Enter First Number:\n");
    scanf("%d", &x);

    printf("Enter Second Number:\n");
    scanf("%d", &y);

    printf("Addition is %d", (x+y));

    return 0;

}
</xmp>

<p>আচ্ছা, যদি তিনটি সংখ্যা যোগ করতে বলে তখন কি করবেন? তিনটি ভ্যারিয়বল নিয়ে তা যোগ করে প্রিন্ট করবেন তাই তো?<br />
 আচ্ছা, যদি তিনশ বা তিনহাজার সংখ্যা নিয়ে কাজ করতে হয় তখন কি করবেন? এত গুলো ভ্যারিয়বল কিভাবে লিখবেন? লিখতে কত সময় লাগবে? আর প্রোগ্রামের সাইজ কত বড় হয়ে যাবে না? আরো অনেক গুলো প্রশ্ন জন্ম নিবে এমন সমস্যায়। যাই হোক, প্রোগ্রামিং এসেছে মানুষের সমস্যা কমাতে, বাড়াতে নয়। তাই এর জন্য অনেক সহজ একটা সমাধান আছে। যার নাম Array, অনেক মজার একটা জিনিস।</p>
<p>এখন আমাকে যদি আপনি জিজ্ঞেস করেন Array কি? তাহলে আমি বলব কন্টেইনার। বাক্স। যেটার মধ্যে অনেক কিছু রাখা যায়। বাক্সটা কেমন হবে তা আমরা বলে দিতে পারি। বাক্সটায় কয়েকটা খোপ/প্রকোষ্ঠ থাকবে তা আমরা বলে দিতে পারি এবং বলে দেওয়ার পর তার মধ্যে সুন্দর মত কিছু ডাটা/তথ্য রাখতে পারি।<br />
 যেমন আমরা ৩০০টি ভ্যারিয়বল নিয়ে কাজ করব, তখন ঐ কন্টেইনার বা বাক্সে ৩০০টি প্রকোষ্ঠ আমাদের জন্য তৈরি হবে। আর আমরা সুন্দর মত একটা একটা করে ভ্যারিয়বল রাখতে পারব বাক্সের মত দেখতে ঐ Array তে। নিছের ছবিটি দেখুনঃ</p>
<img  src="images/one-dimension-array.jpg" alt="" width="629" height="250" /> 
<p>এটা একটা বাক্সের মত দেখায় না যার মধ্যে ৬টি প্রকোষ্ঠ রয়েছে?</p>
<p>Array কিছুটা এমন। আর এটা দেখতে একটা লাইনের মত তাই না? আর তাই এর নাম Linear Array বা One Dimensional Array.<br />
 Array এর ভিতরে যা থাকে তাকে Array Elements বলে। অ্যারেতে  সব ধরনের ডাটা রাখা যায়, এমন Integer, Character, Floating Point Number, String ইত্যাদি। Array তে আরেকটা জিনিস আছে, যার নাম হচ্ছে Index. যা দিয়ে আমরা কোন প্রকোষ্ঠে কিছু রাখতে পারব বা কি রাখছি তা বের করতে পারব। প্রতিটা প্রকোষ্ঠের একটা ইনডেক্স থাকে। Array এর প্রথম Element এর Index হচ্ছে ০, দ্বিতীয় Element এর Index বা উপাদানের হচ্ছে ১ , তৃতীয় উপাদানের হচ্ছে ২ ইত্যাদি। এভাবে বাড়তে থাকবে। উপাদানের নাম্বারের থেকে এক কমই হচ্ছে ইনডেক্স নাম্বার। যেমন ষষ্ঠ উপাদানের ইনডেক্স হচ্ছে ০৫।</p>
<p>ইনডেক্স কি তা এখনি পরিষ্কার হয়ে যাবে। মনে করি আমরা Number নামে একটা Array নিয়েছি যার সাইজ হচ্ছে ৬, সাইজ বলতে অ্যারেতে কয়েটা উপাদান থাকবে তা বুঝানো হচ্ছে।<br />
 অ্যারে হচ্ছে একটা ভ্যারিয়েবল, যাকিছু ধরে রাখতে পারে সাধারন গাণিতিক ভ্যারিয়েবলের মত। এখন আমরা যদি Number নামক Array তে কিছু রাখতে চাই, তাহলে বলে দিতে হবে কোন ঘরে/ইনডেক্সে রাখব।<br />
 যেমন</p>
<p>Number[0] = 77; লিখলে Number Array এর প্রথম ইন্ডেক্সে 77 রেখে দিবে।<br />
 Number[1] = 11; লিখলে Number Array এর দ্বিতীয় ইন্ডেক্সে 11 রেখে দিবে।</p>
<p>Number[2] = 54; লিখলে Number Array এর তৃতীয় ইন্ডেক্সে 54 রেখে দিবে।</p>
<p>এভাবে বাকি ইনডেক্সে অন্যান্য সংখ্যা আমরা রাখতে পারব।</p>
<p>আচ্ছা আমরা এখন একটা প্রোগ্রাম চিন্তা করি যেটা ইউজার থেকে ৬টা নাম্বার নিবে এবং পরে তা যোগ করে রেজাল্ট আমাদের দেখাবে। এটা সাধারন পদ্ধতিতে করতে গেলে আমাদের আগে ৬টা ভ্যারিয়েবল নিতে হত, তারপর সেগুলোকে যোগ করতে হত তারপর যোগফল দেখাতে হতো।</p>
<p>এখন আমরা কত সহজেই এ জিনিসটা করতে পারব মাত্র একটি ভ্যারিয়েবল নিয়েঃ</p>



<xmp>
#include <stdio.h>
int main()

{

    int Number[6];
    int i, result=0;

    for(i=0; i<6; i++){
    printf("Enter %d no Number:\n", i+1);
    scanf("%d", &Number[i]);
    result +=Number[i];
    }

    printf("Result is: %d", result);

    return 0;

}
</xmp>

<p>প্রোগ্রামটা আসলে একটা বাজে প্রোগ্রাম। শুধু মাত্র বুঝানোর জন্য এমন ভাবে লেখা হয়েছে। এখানে আমরা একটা Integer Array নিলাম যার Size হচ্ছে 6, অর্থাৎ আমরা এর মধ্যে শুধু মাত্র ৬টি ইলিমেন্ট রাখতে পারব।<br />
scanf(&#8220;%d&#8221;, &Number[i]); এটা দিয়ে আমরা i এর বর্তমার মান যত তত তম ঘরে ইনপুট নেওয়া মানটি রাখব। প্রথমে i এর মান ধরে নিয়েছি 0, তা Number[0] অর্থাৎ প্রথম ঘরে রানটাইমে আমাদের ইনপুট দেওয়া সংখ্যাটি রাখবে। আমরা যেহেতু লুপ চালিয়েছি এবং প্রতিবার i এর মান এক করে বাড়িয়ে দিয়েছি তাই পরের বার i এর মান হবে 1 এবং Number[1] বা Number Array এর দ্বিতীয় ঘরে রানটাইমে দ্বিতীয়বার ইনপুট দেওয়া আমাদের সংখ্যাটি রাখবে। এভাবে লুপটি ৬ বার ঘুরবে। আমরা বুদ্ধি করে প্রতিবার সংখ্যাটি result +=Number[i] এ লাইনের সাহায্যে ইনপুট নেওয়ার সময় আগের যোগফলের সাথে যোগ করে দিচ্ছি। পরে রেজাল্টি প্রিন্ট করলে আমরা সব গুলো সংখ্যার যোগ ফল পেয়ে যাবো। এখন ইচ্ছে করলে আমরা প্রোগ্রামটি একটু মডিফাই করে কি কি সংখ্যা আমরা ইনপুট দিয়েছি তা বেরও করতে পারব। শুধু মাত্র আরেকটি লুপ চালিয়ে Number Array এর উপাদান গুলো প্রিন্ট করলেই হবে।</p>

<xmp>
#include <stdio.h>
int main()

{

    int Number[6];
    int i, result=0;

    for(i=0; i<6; i++){
    printf("Enter %d no Number:\n", i+1);
    scanf("%d", &Number[i]);
    result +=Number[i];
    }

    printf("Result is: %d", result);

    return 0;

}
</xmp>

<p>Array অনেক প্রয়োজনীয়। অনেক বেশি ব্যবহার এটির।</p>
<p>Array কিন্তু Multi-Dimensional হতে পারে। উপরে আমরা যে উদাহরনটি দেখেছি তা ছিল One-Dimensional এর Dimension সংখ্যা দুই, তিন বা আরো বেশি হতে পারে। Two Dimensional array নিচের মত।</p>
 <img src="images/two-dimensionsl-array.jpg" alt="" width="603" height="425" /> 
<p> এটি একটি Two Dimensional Character Array যার উপাদান সংখ্যা ১২। মনে করি Array টির নাম Character এবং এটিকে লিখতে হবে Character[3][4]  এখানে প্রথমটা হচ্ছে row সংখ্যা, দ্বিতীয়টি হচ্ছে Column সংখ্যা। অর্থাৎ এখানে ৩টি রো রয়েছে এবং ৪টি কলাম রয়েছে, সর্বোমোট উপাদাম সংখ্যা হচ্ছে ১২।<br />
প্রথম উপাধান অর্থাৎ উপরের Character নামক Two Dimensional Array থেকেঃ</p>
<p>প্রথম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][0] এবং তা হচ্ছে A</p>
<p>দ্বিতীয় উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][1] এবং তা হচ্ছে B</p>
<p>তৃতীয় উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][2] এবং তা হচ্ছে C</p>
<p>চতুর্থ উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[0][3] এবং তা হচ্ছে D</p>
<p>পঞ্চম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][0] এবং তা হচ্ছে E<br />
ষষ্ঠ উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][1] এবং তা হচ্ছে F<br />
সপ্তম উপাদানটি পেতে হলে আমাদের লিখতে হবে Character[1][2] এবং তা হচ্ছে G<br />
এভাবে আমরা পরের উপাদান গুলোও পেতে পারি।</p>
<p>কোন কিছু রাখতে হলে এ ভাবে একই ধাপ অনুসরন করতে হবে।<br />
প্রথম ইনডেক্সে একটা Character রাখব, তার জন্য লিখতে হবে Character[0][0]<br />
আগেই বলেছি Array Index শূন্য থেকে শুরু হয়।<br />
দ্বিতীয় ইনডেক্সে একটা Character রাখার জন্য লিখতে হবে Character[0][1]<br />
এভাবে বাকি গুলো রাখতে হবে।</p>
<p> হয়তো প্রথম প্রথম একটু বিদঘুটে লাগতে পারে, দুই একবার ভালো করে পর্যবেক্ষন করলে অনেক সহজ মনে হবে। আর চিন্তা করার সময় যদি বাস্তব জীবনের সাথে মিলিয়ে চিন্তা করা যায় তাহলে আরো দ্রুত বুঝা যাবে।</p>
<p>উদাহরন হিসেবে উপরে আমি সি প্রোগ্রামিং ব্যবহার করেছি। অ্যারের মূল ধারনা এবং ব্যবহার সকল প্রোগ্রামিং এ একই। শুধু মাত্র অ্যারে ডিক্লেয়ার করার পদ্ধতি ভিন্ন।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3474">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিংঃ পয়েন্টার</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>পয়েন্টার প্রোগ্রামিং এ দারুন একটি টুল। পয়েন্টার সম্পর্কে জানার আগে কিছু ব্যাসিক জিনিস জানা যাক, যেগুলো বুঝতে কাজে দিবে।</p>

<p>ভ্যারিয়েবল গুলো কিভাবে কম্পিউটার মেমরিতে/ র‍্যাম এ স্টোর হয়?</p>
<p>র‍্যাম এর এক একটি সেল এক একটি বাইট। আর প্রত্যেকটা বাইট এর একটি করে এড্রেস রয়েছে। আর প্রতিটা বাইটে ৮টি করে বিট রয়েছে।</p>
<p><a href="images/memory-cell-in-ram.jpg" rel="lightbox[3474]" title="memory cell in ram"><img class="aligncenter size-full wp-image-1720" src="images/memory-cell-in-ram.jpg" alt="memory cell in ram" width="473" height="479" srcset="images/memory-cell-in-ram-296x300.jpg 296w, images/memory-cell-in-ram.jpg 473w" sizes="(max-width: 473px) 100vw, 473px" /></a></p>

<p>আমরা যখন বলি আমাদের র‍্যাম 8 Giga byte, তখন আমাদের কম্পিউটারের র‍্যামে মোট 8 000 000 000 bytes ডেটা স্টোর করা যাবে, এবং এদের প্রত্যেকের একটি করে এড্রেস রয়েছে। প্রথমটি ০ পরের টি 1, এর পরের টির এড্রেস 2 এভাবে বাড়তে থাকে।  যদিও কম্পিউটার এ এড্রেস গুলো রিপ্রেজেন্ট করে হেক্সাডেসিমেল নাম্বার সিস্টেমে।</p>
<p>আমরা যখন একটি ভ্যারিয়েবল ডিক্লেয়ার করার পর যখন প্রোগ্রামটি এক্সিকিউট/রান করি তখন কম্পিউটার ঐ ভ্যারিয়েবল এর জন্য কিছু মেমরি এলোকেট করে। কত বাইট মেমরি এলোকেট করবে, তা নির্ভর করে ঐ ভ্যারিয়েবল এর ডেটা টাইপ এবং কম্পাইলার এর উপর।</p>
<p>সাধারনত কম্পাইলার গুলো একটা int এর জন্য 2 byte মেমরি এলোকেট করে। তেমনি একটি char ভ্যারিয়েবলের জন্য 1 byte মেমরি এলোকেট করে। floating-point নাম্বার এর জন্য 4 byte মেমরি এলোকেট করে।</p>
<p>যেমন যখন কম্পিউটার দেখে এমন একটি ডিক্লারেশন int a; তখন এটি বুঝতে পারে এটি একটি ইন্টিজার ভ্যারিয়েবল এবং এর জন্য ২ বাইট মেমরি এলোকেট করা দরকার। তখন র‍্যাম এর খালি যায়গা থেকে এটি এই ইন্টিজারের জন্য ২ বাইট মেমরি এলোকেট করে।</p>
<p>আমরা সহজেই একটি ভ্যারিয়েবলের মেমরি লোকেশন বের করতে পারি, নিচের প্রোগ্রামটি দেখা যাকঃ</p>
<xmp>

#include <stdio.h>
int main()
{
int a =5;
printf("Memory address of variable a is: %x",&a);
return 0;
}

</xmp>
<p>উপরের প্রোগ্রামটি রান করালে এমন কিছু দেখাবেঃ Memory address of variable a is: 2686732 । এক কম্পিউটারে এক এক মান দেখাবে। এবং একবার এক এক ভ্যালু দেখাবে। কারণ যতবারই আমরা প্রোগ্রামটি রান করি, প্রতিবারই ভ্যারিয়েবলটির জন্য মেমরিতে একটা জায়গা বরাদ্ধ করা হয়। আর ঐ জায়গার এড্রেসটা প্রতিবারই পরিবর্তন হয়। </p>
<p>কোন ভ্যারিয়েবল এর এর মেমরি এড্রেস জানার জন্য & [ampersend] ব্যবহার করা হয়। যাকে  address-of operator [&] ও বলা হয়।  যা দিয়ে আমরা অন্য একটি ভ্যারিয়েবল এর  এড্রেস বা মেমরি লোকেশন পেতে পারি।</p>
<p>যখন আমরা প্রোগ্রামটি রান করি, তখন কম্পিউটার র‍্যাম এর খালি যায়গা থেকে ভ্যারিয়েবল a এর জন্য ২ বাইট মেমরি এলোকেট করে। কম্পিউটার অটোমেটিকেলি তখন a এর জন্য 2686732 এবং 2686733 নং সেল এলোকেট করে রাখে। আর মেমরি এড্রেস জানার জন্য শুধু মাত্র শুরুর এড্রেস জানলেই হয়। আমরা যখন a এর মেমরি এড্রেস প্রিন্ট করেছি, তখন শুধু শুরুর এড্রেস 2686732 ই পেয়েছি। যদি ও a ভ্যারিয়েবল এর জন্য 2686732 এবং 2686733  মেমরি এলোকেট করা হয়েছে এবং এর মান 5 এই দুই সেলে স্টোর করে রাখা হয়েছে। এখন আমরা যদি a এর মান পরিবর্তন করে অন্য আরেকটা ভ্যালু রাখি, যেমন 8, তখন র‍্যামের 2686732 এবং 2686733 এ দুটো সেল এর মান ও পরিবর্তন হয়ে যাবে এবং এ দুটো সেলে 5 এর পরিবর্থে 8 স্টোর হবে। এবার পয়েন্টার কি জানা যাক।</p>
<p><strong>পয়েন্টার হচ্ছে একটা ভ্যারিয়েবল যার ভ্যালু হচ্ছে আরেকটি ভ্যারিয়েবল এর মেমরি লোকেশন।</strong> পয়েন্টার  একটা ডেটা, অ্যারে বা ভ্যারিয়েবল এর কম্পিউটার মেমরি লোকেশন  রিপ্রেজেন্ট করে বা পয়েন্ট করে। অন্যান্য ভ্যারিয়েবল এর মত  পয়েন্টার ভ্যারিয়েবল ব্যবহার করার আগে কম্পিউটার/ কম্পাইলারকে বলতে হবে এটা একটি পয়েন্টার ভ্যারিয়েবল। নিচের মত করে একটি পয়েন্টার ভ্যারিয়েবল ডিক্লেয়ার করে।</p>
<p>data_type *name;</p>
<p>যেমন integer পয়েন্টারের জন্যঃ  int *i;</p>
<p>asterisk [*] একটি ভ্যারিয়েবলের আগে ব্যবহার করে পয়েন্টার হিসেবে ডিক্লেয়ার করা হয়। যাকে indirection operator বা value-at-address operator বলা হয়। এখানে আরো কিছু ডেটা টাইপ এর পয়েন্টার ডিক্লারেশন এর উদাহরন দেওয়া হলোঃ</p>
<xmp>
int*ip;/* pointer to an integer */
double*dp;/* pointer to a double */
float*fp;/* pointer to a float */
char*ch /* pointer to a character */
</xmp>
<p>আমরা এখন দেখব কিভাবে পয়েন্টার ব্যবহার করতে হয় একটি প্রোগ্রামে।</p>
<xmp>

#include <stdio.h>
int main ()
{
int a = 5; /* variable declaration */
int *ip; /* pointer variable declaration */
ip = &a; /* store address of "a" in pointer variable*/
printf("Address of a variable: %xn", &a );
/* address stored in pointer variable */
printf("Address stored in ip variable: %xn", ip );
return 0;
}

</xmp>
<p>এখানে আমরা একটি ভ্যারিয়েবল a ডিক্লেয়ার করেছি। এরপর একটি পয়েন্টার ভ্যারিয়েবল ডিক্লেয়ার করেছি। তারপর পয়েন্টার ভ্যারিয়েবলে a এর মেমরি এড্রেস রেখেছি। তারপর & অপারেটর দিয়ে a ভ্যারিয়েবল এর এড্রেস প্রিন্ট করে দেখলাম। এবং পয়েন্টার ভ্যারিয়েবল এর ভ্যালু প্রিন্ট করে দেখলাম। উভয় এর মান ই একই।</p>
<p>আমরা ইচ্ছে করলে এখন ip  পয়েন্টার ভ্যারিয়েবল দিয়ে a এর মান বের করতে পারি।</p>
<xmp>

#include <stdio.h>
int main ()
{
int a = 5;
int *ip;
ip = &a;
/* access the value using the pointer */
printf("Value of *ip variable: %dn", *ip );
return 0;
}

</xmp>
<p>আমরা যখন প্রগ্রামটি রান করব, তখন ip যে ভ্যারিয়েবলটির এড্রেস শো করবে, তার মান প্রিন্ট করবে। লক্ষকরি, যখন আমরা পয়েন্টার ভ্যারিয়েবল দিয়ে কোন ভ্যারিয়েবল এর এড্রেস বের করতে চাইবো, তখন শুধু পয়েন্টার ভ্যারিয়েবল লিখলেই হবে। কিন্তু যখন আমরা পয়েন্টার ভ্যারিয়েবল দিয়ে মূল ভ্যারিয়েবল এর ভ্যালু বের করতে চাইবো, তখন পয়েন্টার ভ্যারিয়েবল এর আগে <strong>*</strong> যোগ করতে হবে। যেমন প্রথম প্রোগ্রামে আমরা ip [পয়েন্টার ভ্যারিয়েবল] প্রিন্ট করায় আমরা এড্রেস পেয়েছি। এবং পরের প্রোগ্রামে ip এর আগে একটা * দিয়ে *ip প্রিন্ট করায় আমরা মূল ভ্যারিয়েবলের মান পেয়েছি।</p>


 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3475">

	<div data-role="header">	
	
		<h1>সি প্রোগ্রামিংঃ স্ট্রাকচার - struct</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p><strong>Structures </strong>সি প্রোগ্রামিং এর দারুণ একটা বিষয়। আমরা ডেটা টাইপ সম্পর্কে জানি, int, char, float ইত্যাদি।  Structures দিয়ে আমরা নিজেদের মত করে ডেটা স্ট্রাকচার তৈরি করে নিতে পারি। যেমন অ্যারে হচ্ছে একটা ডেটা স্ট্র্যাকচার। যেখানে শুধু আমরা একই ডেটা টাইপ এর ডেটা রাখতে পারি। কিন্তু স্ট্র্যাকচার তৈরি করে আমরা এক সাথে int, char, float ইত্যাদি ভিন্ন ভিন্ন ডেটা এক সাথে রাখতে পারি। নিজেদের প্রয়োজন মত, ইচ্ছে মত। </p>
<p>int অ্যারেতে শুধু ইন্টিজার ভ্যালুই রাখতে পারব। char অ্যারেতে শুধু কারেকটারই রাখতে পারব। কিন্তু Structures ব্যবহার করে আমরা নিজেদের মত করে ডেটা স্ট্রাকচার তৈরি করতে পারব। এবং ঐখানে ইচ্ছে মত একের অধিক ভিন্ন ভিন্ন ডেটা রাখতে পারব। </p>
<p>Structures নিচের মত করে ডিফাইন করা হয়।<br />
<strong><em>    struct book<br />
            {<br />
                        int no;<br />
                        char name;<br />
            };  </em></strong><br />
struct কীওয়ার্ড দিয়ে Structures ডিফাইন করা হয়। এরপর লিখছি book, যা হচ্ছে আমাদের নিজস্ব স্ট্র্যাকচারের নাম। এরপর দ্বিতীয় ব্র্যাকেটের মধ্যে স্ট্র্যাকচারের মেম্বার গুলো।<br />
এখানে একটা মেম্বার হচ্ছে ইন্টিজার, যেখানে আমরা বই এর ক্রমিক নাম্বার রাখব। আরেকটা হচ্ছে কারেকটার, যেখানে আমরা বইটির নাম রাখব।</p>
<p>Structures   ডিফাইন করার পর তা ব্যবহার করার জন্য ডিক্লেয়ার করতে হয়। একটা ইন্টিজার ভ্যারিয়েবল ব্যবহারের জন্য যেমন আগে তা ডিক্লেয়ার করতে হয়, তেমনি।</p>
<p>ডিক্লেয়ার করার জন্য  নিচের মত করে লিখতে হয়ঃ<br />
<em><strong>    struct book myBook;</strong></em></p>
<p>যেখানে struct দিয়ে বুঝায় আমরা একটা স্ট্র্যাকচার ডিক্লেয়ার করতে যাচ্ছি, এরপর book, যা দিয়ে বুঝাচ্ছে আমরা কোন struct টা ডিক্লেয়ার করতে যাচ্ছি। এরপর হচ্ছে আমরা কি নামে আমাদের তৈরি স্ট্র্যাকচারটা ব্যবহার করব। </p>
<p>ডিক্লেয়ার করার পর স্ট্র্যাকচার ব্যবহার করতে হবে। তো আমরা আমাদের তৈরি myBook স্ট্র্যাকচার ব্যবহার করব। </p>
<p>myBook এর দুইটা মেম্বার। একটা হচ্ছে  no আরেকটা name.</p>
<p>এখন আমরা বই এর নাম্বার এবং নাম সেট করব। তার জন্য লিখতে হবেঃ<br />
<em><strong>myBook.no = 3;<br />
myBook.name = ‘C’;</strong></em></p>
<p>এবার আমাদের সেট করা বই এর নাম এবং নং প্রিন্ট করতে চাইলেঃ</p>
<xmp>
printf( "Book No : %dn", myBook.no); 
printf( "Book Name : %cn", myBook.name);
</xmp>
<p>আমরা ছোট ছোট কোড লিখেছি, এবার পুরো প্রোগ্রামটি লিখে ফেলিঃ</p>

<xmp>
#include <stdio.h>

    struct book{
        int no;
        char name;
        };

int main ()
{
    struct book myBook;
    myBook.no = 3;
    myBook.name = 'C';

    printf( "Book No : %d\n", myBook.no);
    printf( "Book Name : %c\n", myBook.name);

    return 0;
}
</xmp>

<p>typedef ব্যবহার করে আমরা আমাদের স্ট্র্যাকচারের instanc তৈরি করার সময় struct কীওয়ার্ড ব্যবহার ছাড়াই আমাদের তৈরি স্ট্র্যাকচার ব্যবহার করতে পারি। তার জন্য আমাদের উপরের স্ট্যাকচারটা নিচের মত করে লিখতে হবেঃ</p>
<p>        typedef struct  {<br />
                        int no;<br />
                        char name;<br />
            } book;</p>
<p>আগের থেকে পার্থক্য হচ্ছে আমরা এখানে নতুন একটা কীওয়ার্ড ব্যবহার করেছি, typedef। তারপর লিখছি struct। এবং আমাদের স্ট্র্যাকচারের একবারে শেষের দিকে লিখেছি আমাদের স্ট্যাকচারের নাম। </p>
<p>এখন আমরা আমাদের এই book স্ট্র্যাকচারের instance তৈরি করার জন্য struct কীওয়ার্ড ব্যবহার ছাড়াই তৈরি করতে পারব, যেমনঃ<br />
book myBook;</p>
<p>যেভাবে আমরা একটা ভ্যারিয়েবল ডিক্লেয়ার করি, ঠিক সেভাবে।  আগের প্রোগ্রামটা <strong>typedef </strong>ব্যবহার করলে হয়ঃ</p>


<xmp>
#include <stdio.h>

   typedef struct book{
        int no;
        char name;
        } book;

int main ()
{
    book myBook;
    myBook.no = 3;
    myBook.name = 'C';

    printf( "Book No : %d\n", myBook.no);
    printf( "Book Name : %c\n", myBook.name);

    return 0;
}
</xmp>

<p>আচ্ছা, স্ট্রাকচার এর সুবিধে হচ্ছে একবার ডিফাইন করার পর ইচ্ছে মত instance তৈরি করে নিতে পারি আমরা। আগের দুইটি প্রোগ্রামে আমরা একটা স্ট্রাকচার ডিফাইন করেছি, এবং এরপর একটা মাত্র স্ট্রাকচার ডিক্লেয়ার করেছি। এখন আমরা আরেকটা প্রোগ্রাম লিখব, যেখানে একটা স্ট্রাকচারের  তিনটে instance তৈরি করব। </p>
<xmp>

#include <stdio.h>

   typedef struct book{
        int no;
        char name;
        } book;

int main ()
{
    book book1;
    book book2;
    book book3;

    book1.no = 1;
    book1.name = 'A';


    book2.no = 2;
    book2.name = 'B';


    book3.no = 3;
    book3.name = 'C';

    printf( "Book No : %d\n", book1.no);
    printf( "Book Name : %c\n \n", book1.name);

    printf( "Book No : %d\n", book2.no);
    printf( "Book Name : %c\n \n", book2.name);

    printf( "Book No : %d\n", book3.no);
    printf( "Book Name : %c\n", book3.name);




    return 0;
}
</xmp>

<p>book এর instance তৈরি করার সময় আমরা ভিন্ন ভিন্ন লাইনে না লিখে একই লাইনে লিখতে পারি। যেমনঃ</p>
<p><em>    book book1;<br />
    book book2;<br />
    book book3;</em></p>
<p>এর পরিবর্তে আমরা লিখতে পারিঃ   <strong><em> book book1,book2, book3;</em></strong></p>
<p>আমরা book এর তিনটে instance তৈরি করেছি মাত্র। এবং ম্যানুয়ালি সব গুলো মেম্বারে ডেটা সেট করেছি। কিন্তু আমাদের এমন প্রোগ্রাম লিখতে হবে, যেখানে আমাদের ১০০ বা ১০০০ বা আরো বেশি instance তৈরি করতে হবে। তখন কি করব? এমন প্রোগ্রামটা দেখতে কি বিশ্রিই না দেখাবে, তাই না? কিন্তু না, আমরা এখানে কন্ডিশনাল ব্যবহার করতে পারব। লুপ দিয়ে সব গুলোতে ডেটা সেট করতে পারব। আবার লুপ দিয়ে সব গুলো থেকে ডেটা বের করে প্রিন্ট করতে পারব। </p>
<p>আমরা সিম্পল একটা প্রোগ্রাম লিখব এ জন্য। আসলে এ প্রোগ্রামটির জন্য স্ট্র্যাকচার ব্যবহার করতে হয় না। তারপর ও লুপ ব্যবহার করে কিভাবে স্ট্র্যাকচারের ভিন্ন ভিন্ন মেম্বার এক্সেস  করতে হয়, তার একটা উদাহরণ দেখব।</p>
<p>প্রোগ্রামটিতে আমরা ০ থেকে ১০০ এর বর্গমুল [square root] এর একটা চার্ট তৈরি করব। </p>

<xmp>
#include <stdio.h>

   typedef struct squareRoot{
        int number[100];
        double root[100];
        } squareRoot;

int main ()

{
    int i =0;
    squareRoot squareRoot1;

// setting data
    for (i =0; i<=100; i++){

        squareRoot1.number[i] = i;
        squareRoot1.root[i] = sqrt(i);
    }

// printing data

    for (i =0; i<=100; i++){
    printf( "Square Root of %d ", squareRoot1.number[i]);
    printf( "is : %f\n", squareRoot1.root[i]);
    }

    return 0;
}
</xmp>
<p>এখানে sqrt() হচ্ছে একটা লাইব্রেরী ফাংশান। যার মধ্যে একটা নাম্বার দিলে ঐ নাম্বারটির বর্গমূল রিটার্ন করে। বাকি কোড গুলো তো সহজ। প্রথমে আমরা for লুপ ব্যবহার করে আমাদের squareRoot1 এর বিভিন্ন মেম্বারে ডেটা সেট করেছি। এপর আবার লুপ দিয়ে সেগুলো প্রিন্ট করেছি। এবার তো আমরা স্ট্র্যাকচার ব্যবহার করে কমপ্লেক্স কোড লিখতে পারব, তাই না? শুভ প্রোগ্রামিং&#8230; </p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c3476">

	<div data-role="header">	
	
		<h1>ফাইল অপারেশন</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>একটা ফাইল নিয়ে কাজ করার জন্য তা ডিক্লেয়ার করতে হয়। ডিক্লেয়ার করা হয় FILE পয়েন্টার দিয়ে। যেমনঃ</p>
<p>FILE *MyFile;</p>
<p>FILE বড় হাতের অক্ষরে লিখতে হয় এবং MyFile হচ্ছে পয়েন্টার ভেরিয়েবল। এটা মুলত একটা বাফার তৈরি করে কম্পিউটার মেমরি এবং ঐ ফাইল এর মধ্যে। পয়েন্টার ভেরিয়েবল তৈরি করার পর আমরা ফাইলটি ওপেন করতে পারব। তার জন্য fopen ফাংশান ব্যবহার করতে হয়। যা সাধারনত লেখা হয় এমনঃ MyFIle = fopen(file-name, file-type); । ফাইল এর নাম এবং টাইফ দুটি স্ট্রিং । এবং ফাইল টাইপ হচ্ছে ফাইলটা কোন মুড এ ওপেন হবে তা। যেমন Read Only, Write Only অথবা দুটিই ইত্যাদি। যেমনঃ</p>
<p>MyFile = fopen (&#8220;myfile.txt&#8221;,&#8221;w&#8221;);<br />
file-type নিচের টেবিলের যে কোন একটা হতে পারেঃ</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="50"><strong>r</strong></td>
<td valign="top" width="319">শুধু মাত্র ফাইলটি রিড করার জন্য ওপেন করা।</td>
</tr>
<tr>
<td valign="top" width="10"><strong>w</strong></td>
<td valign="top" width="319">
<ul>
<li>ফাইলটিতে কিছু রাইট করার জন্য ওপেন করা।</li>
<li>ফাইলে যদি আগে কিছু থাকে তাহলে তা মুছে যাবে।</li>
<li>ফাইল যদি না থাকে, তাহলে অটোমেটিক ভাবে তৈরি হবে।</li>
</ul>
</td>
</tr>
<tr>
<td valign="top" width="10"><strong>a</strong></td>
<td valign="top" width="319">
<ul>
<li>ফাইলের শেষে কিছু রাইট করার জন্য ওপেন করা।</li>
<li>যদি ফাইলে আগে কিছু থাকে, তাহলে তার শেষে রাইট হবে।</li>
<li>ফাইল যদি না থাকে, তাহলে অটোমেটিক ভাবে তৈরি হবে।</li>
</ul>
</td>
</tr>
<tr>
<td valign="top" width="10"><strong>r+</strong></td>
<td valign="top" width="319">ফাইলটি রিড করা বা রাইট করার জন্য ওপেন করা। এবং ফাইলের শুরুতে কিছু লেখা।</td>
</tr>
<tr>
<td valign="top" width="10"><strong>w+</strong></td>
<td valign="top" width="319">ফাইলটি রিড করা বা রাইট করার জন্য ওপেন করা।</td>
</tr>
<tr>
<td valign="top" width="10"><strong>a+</strong></td>
<td valign="top" width="319">ফাইলটি রিড করা বা রাইট করার জন্য ওপেন করা। এবং ফাইলের শেষে কিছু লেখা।</td>
</tr>
</tbody>
</table>
<p>ফাইল ওপেন করার জন্য তাতে কিছু লেখার জন্য fputs ফাংশান ব্যবহার করা হয়। যেমনঃ</p>
<p>fputs (&#8220;Writing to a file using &#8216;fopen&#8217; example.&#8221;,MyFile);</p>
<p>ফাইলটি রিড বা রাইট করা হলে ফাইলোটি বন্ধ বা ক্লোজ করতে হয়, তার জন্য ব্যবহার করা হয়  fclose ফাংশানঃ</p>
<p>fclose (MyFile);</p>

<xmp>
#include <stdio.h>
 
int main ()
{
 FILE * MyFile;
 MyFile = fopen ("myfile.txt","w");
 if (MyFile!=NULL)
     {
         fputs ("Writing to a file using 'fopen' example.",MyFile);
         fclose (MyFile);
     }
 return 0;
}
</xmp>
<p>আপনার সি প্রোজেক্টটা যে ফোল্ডারে সংরক্ষিত করছেন তা ওপেন করুন। তার ভেতর myfile.txt দেখতে পাবেন। এবং ফাইলটি ওপেন করলে Writing to a file using &#8216;fopen&#8217; example. লেখাটি দেখতে পাবেন।</p>
<p><strong>ফাইল থেকে ডেটা পড়াঃ</strong></p>
<p>ফাইল থেকে ডেটা পড়ার জন্য fscanf ব্যবহার করা হয়।</p>
<p>নিচের কোড গুলো দেখুনঃ</p>
<xmp>
#include <stdio.h>
int main ()
{
 FILE * MyFile;
 char string[10];
 MyFile = fopen ("myfile.txt","r+");
 
while(! feof(MyFile))
 {
 fscanf(MyFile,"%s",string);
 
printf("%s ", &string);
 }
 fclose (MyFile);
 return 0;
}


</xmp>
<p>এখানে feof দিয়ে end-of-file চেক করা হয়েছে। অর্থাৎ যতক্ষন পর্যন্ত ফাইলের মধ্যে কোন ডেটা থাকবে ততক্ষন পর্যন্ত ফাইলটির ডেটা গুলো fscanf দিয়ে রিড করা হবে।<br />
fscanf এর তিনটা প্যারামিটার রয়েছে। fscanf(file-name, data-type, variable);<br />
file-name হচ্ছে ফাইলের নাম। যে ফাইল থেকে ডেটা পড়া হবে। data-type হচ্ছে ফাইলের ডেটা টাইফ। বা কোন টাইফে ডেটা গুলো পড়া হবে। এখানে char টাইফের ডেটা পড়া হয়েছে। ইচ্ছে করলে int অথবা floating point ডেটা পড়া যাবে।<br />
variable হচ্ছে ভেরিয়েবলের নাম, যেখানে ডেটা গুলো ফাইল থেকে পড়ে সংরক্ষিত থাকবে।<br />
আমরা এ পর্যন্ত যে ফোল্ডারে আমাদের সি প্রোগ্রাম টা রয়েছে তা থাকে ফাইলটি ওপেন করছি বা রিড করছি। ইচ্ছে করলে আমরা যে কোন ডিরেক্টরি থেকে ফাইলটি ওপেন করতে পারি। file-name এর জায়গায় পুরো ফাইল পাথ দিলেই হবে। নিচের উদাহরনটি দেখুনঃ</p>
<xmp>
#include <stdio.h>
 
int main ()
{
 FILE * MyFile;
 char string[10];
 MyFile = fopen ("myfile.txt","r+");
 
while(! feof(MyFile))
 {
    fscanf(MyFile,"%s",string);
    printf("%s ", &string);
 }

</xmp>
<p>ফাইল নিয়ে কাজ করা অনেক সহজ তাই না?</p>
<p>টেবিলে আগেই বলছি যে w মুডে ফাইলটি ওপেন করলে তার মধ্যের সকল ডেটা মুছে যাবে এবং নতুন করে ডেটা রাইট হবে। কিন্তু আমরা যদি আগের ডেটা না মুছে আগের ডেটার নিছে নতুন ডেটা লিখতে চাই তার জন্য ব্যবহার করব a মুড।</p>
<p>নিচের কোড টি কয়েকবার রান করিয়ে দেখুনঃ</p>
<xmp> 
#include <stdio.h>
int main ()
{
 FILE * MyFile;
 MyFile = fopen ("F:\MyFolder\myfile.txt","a");
 if (MyFile!=NULL)
 {
     fputs ("Writing to a file using 'fopen' example.",MyFile);
     fclose (MyFile);
 }
 return 0;
}
</xmp>
<p>এতটুকুই, অন্যান্য মুড আপনারা ট্রাই করে দেখুন। অন্য কোন ডেটা টাইপ সংরক্ষণ করে দেখুনন। অন্য ডেটা টাইপের ডেটা গুলো আবার রিড করার চেষ্টা করুন। </p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c497">

	<div data-role="header">	
	
		<h1>সি পোগ্রামিং - Strings / স্ট্রিং</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>স্ট্রিং হচ্ছে কারেকটার সেট। একটা ওয়ার্ড, একটা বাক্য, একটা প্র্যারাগ্রাফ, সব গুলোই স্ট্রিং। যেমন Hello World একটা স্ট্রিং। আবার hello ও একটা স্ট্রিং। world ও একটা স্ট্রিং। যখন শুধু একটা বর্ণ, তখন তা কারেকটার।</p>
<p>আগে বলেছি স্ট্রিং হচ্ছে কারেকটার সেট। হ্যা, একটা one-dimensional কারেকটার অ্যারে হচ্ছে স্ট্রিং। লেখাটি পড়ার আগে <strong> অ্যারে/Array  </strong>সম্পর্কে ধারণা থাকা লাগবে। একটা স্ট্রিং নিচের মত করে ডিক্লেয়ার করা হয়ঃ<br />
<em>char string[50] = &#8220;This is a static string&#8221;;</em></p>
<p>আর প্রিন্ট করার জন্য লিখতে হয়ঃ<br />
<em>printf(&#8220;%sn&#8221;, string);</em></p>
<p>আমরা একটা স্ট্রিং ডিক্লেয়ার এবং তা প্রিন্ট করার জন্য একটা প্রোগ্রাম লিখে ফেলিঃ</p>

<xmp>
#include <stdio.h>
#include <string.h>
int main ()
{
    char string[50] = "Hello";
    printf("%s\n", string);

    return 0;
}

</xmp>
<p> 

Hello এ স্ট্রিংটা প্রিন্ট করার জন্য আমরা 50 সাইজের একটা কারেকটার অ্যারে ডিক্লেয়ার করেছি, কিন্তু আমাদের বর্ণ মাত্র ৫টা। তাই আমাদের এত বড় অ্যারে ডিক্লেয়ার করার দরকার নেই। তার জন্য আমরা 5 সাইজের একটা অ্যারে ডিক্লেয়ার করলেই হবে। এখানে বলে রাখা ভালো যে, আমরা যখন একটা স্ট্রিং ডিক্লেয়ার করব, তখন সব গুলো বর্ণের শেষে অটোমেটিক্যালি একটা null character &#8216;&#8217; যুক্ত হবে। নিচের ছবিটা দেখি।</p>
<p> <img  src="images/string_representation.jpg"   /> </p>
<p>Hello স্ট্রিং এর জন্য আমাদের টোটাল তাহলে ৬ সাইজের একটা অ্যারে দরকার। Hello এর পাঁচটা বর্ণ এবং একটা নাল কারেকটার। আবার আমরা জানি অ্যারে এর indexing শুরু হয় ০ থেকে। তাহলে আমাদের Hello স্ট্রিং নিচের মত করেও ডিক্লেয়ার করতে পারিঃ</p>
<p><em>char string[5] = &#8220;Hello&#8221;;</em></p>
<p>আবার আমরা চাইলে কত সাইজের অ্যারে ব্যবহার করব তা রান টাইমের উপর ছেড়ে দিতে পারি। প্রোগ্রাম অটোম্যাটিক্যালি একটা সাইজ এসাইন করে দিবে। তার জন্য লিখবঃ</p>
<p><em>char string[] = &#8220;Hello&#8221;;</em></p>
<p>এবার একটা প্রোগ্রাম লিখি, যেখানে ইউজার থেকে একটা ব্যাক্য ইনপুট নিবে, এবং পরে তা প্রিন্ট করবেঃ
</p>
<xmp>
#include <stdio.h>
#include <string.h>
int main ()
{
    char string[100];
    printf("Enter a sentance: ");

    scanf(" %[^\n]s", &string);
    printf("%s\n", string);

    return 0;
}
</xmp>

<p>উপরের প্রোগ্রামে আমরা scanf এর ভেতর লিখছি %[^n]s। scanf দিয়ে স্পেস ইনপুট নেওয়া যায় না। তার জন্য স্পেশাল মডিফায়ার ব্যবহার করতে হয়। সে জন্য এভাবে লেখা। আর scanf ছাড়া আমরা gets দিয়ে স্ট্রিং ইনপুট নিতে পারি। gets দিয়ে উপরের প্রোগ্রাম লিখলে হবেঃ<br />
</p>
<xmp>
#include <stdio.h>
#include <string.h>
int main ()
{
    char string[100];
    printf("Enter a sentance: ");

    gets(string);
    printf("%s\n", string);

    return 0;
}
</xmp>



<p>সিম্পল, তাই না?</p>
<h3><strong>Strings Concatenation</strong></h3>

<p>Concatenation মানে হচ্ছে জোড়া দেওয়া। দুইটা আলাদা আলাদা স্ট্রিং এক সাথ করার জন্য Strings Concatenation ব্যবহার করা হয়। এর জন্য একটা লাইব্রেরী ফাংশান রয়েছে। strcat(), যা ব্যবহার করে দুইটা স্ট্রিং এক সাথ করা যায়। strcat() ইনপুট হিসেবে দুইটা স্ট্রিং নেয়। এভাবেঃ strcat(string1, string2) এরপর string2 এর ভেতরে থাকা স্ট্রিং string1 এর সাথে যুক্ত করে দেয়, নিচের প্রোগ্রামটি দেখিঃ
</p>
<xmp>
#include <stdio.h>
#include <string.h>
int main ()
{
    char string1[] =  "Hello ";
    char string2[] = "World";
    strcat(string1, string2);

    printf("%s\n", string1);

    return 0;
}

</xmp>
<h3><strong>strcmp()</strong></h3>
<p>দুইটা স্ট্রিং কম্পেয়ার করার জন্য ব্যবহার করা হয় strcmp(string1, string2)। দুইটা স্ট্রিং এ ফাংশনে পাস করলে তিনটা মান রিটার্ন করেঃ</p>
<ul>
<li><strong>রিটার্ন ভ্যালু ০ থেকে ছোট হবে যদি string1 থেকে string2 বড় হয়।</strong></li>
<li><strong>রিটার্ন ভ্যালু ০ থেকে বড় হবে যদি string1 থেকে string2 ছোট হয়।</strong></li>
<li><strong>রিটার্ন ভ্যালু ০ হবে, যদি দুইটা স্ট্রিং একই হয়। </strong></li>
</ul>

<xmp>
#include <stdio.h>
#include <string.h>
int main(){

    int ret;
    char string1[50], string2[50];
    printf("Enter string 1:");
    gets(string1);

    printf("Enter string 2:");
    gets(string2);

    ret = strcmp(string1, string2);

    if(ret < 0){
          printf("string1 is less than string2");
       }
   else if(ret > 0){
          printf("string2 is less than string1");
       }
   else{
          printf("string1 is equal to string2");
       }



   return 0;
}

</xmp>

<h3><strong>strcpy()</strong></h3>

<p>strcpy() তে দুইটা স্ট্রিং পাস করলে দ্বিতীয় স্ট্রিং এর ভ্যালু প্রথম স্ট্রিং এ কপি করবে। যেমন strcpy(string1, string2) পাস করলে string2 এর ভেতরের স্ট্রিংটা string1 এ এসাইন হয়ে যাবে। নিচের প্রোগ্রামটি দেখিঃ</p>
<xmp> 
#include <stdio.h>
#include <string.h>
int main ()
{
    char string1[] =  "Hello ";
    char string2[] = "World";
    strcpy(string1, string2);

    printf("%s\n", string1);
    printf("%s\n", string2);

    return 0;
}
</xmp>

<p>এবার আমরা একটা প্রোগ্রাম লিখব, যেখানে একটা বাক্য থেকে কোন একটা বর্ণ কতবার আছে, তা বের করতে পারব। ইনপুট হিসেবে একটা বাক্য নিবে। তারপর নিবে কোন বর্ণটার সংখ্যা বের করতে হবে, তা। এবং পরে ঐ বর্ণটা কতবার রয়েছে, তা প্রিন্ট করবেঃ</p>

<xmp> 
#include <stdio.h>
#include <string.h>
int main(){
   char sentence[1000];
   char character;
   int i,count=0;
   printf("Enter a sentence: ");
   gets(sentence);
   printf("Enter a character to find frequency: ");
   scanf("%c",&character);

   for(i=0; sentence[i]!='\0';++i)
   {
       if(character==sentence[i])
           ++count;
   }
   printf("Frequency of %c = %d", character, count);
   return 0;
}
</xmp>

<p>উপরের প্রোগ্রামটাতে প্রথমে ইজার থেকে একটা বাক্য ইনপুট নিচ্ছে gets দিয়ে। এরপর ইনপুট নিচ্ছে কোন কারেকটার / বর্ণটি কত বার রয়েছে, তা। এরপর for লুপ চালিয়ে আমরা বর্ণটি কাউন্ট করেছি। এরপর শেষে বর্ণটি কতবার রয়েছে, তা প্রিন্ট করেছি। for লুপে আমরা sentence[i]!=&#8217;’ ব্যবহার করেছি। এর মানে হচ্ছে for লুপটি ততক্ষণ পর্যন্ত চলবে, যতক্ষণ না নাল কারেকটারটি পায়। আর আমরা জানি প্রত্যেকটা স্ট্রিং অ্যারের শেষে একটা নাল কারেকটার থেকে।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c499">

	<div data-role="header">	
	
		<h1>ফ্লো চার্ট / Flow Chart  / প্রবাহ চিত্র</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>কাজ  করার ধাপ গুলোর চিত্রিত রুপ হচ্ছে ফ্লো চার্ট।</p>
<p>এখানে কাজ বলতে যে কোন কাজ। বাজার করতে যাওয়া ,  একটা কম্পিউটার প্রোগ্রাম লেখা , কোন একটা সমস্যা সমাধান করা, আস্ত একটা গেম তৈরি করে ফেলা। সব গুলো কাজ করতে কিছু ধাপ অনুসরন করতে হয়। এই ধাপ গুলোকে বলে <strong>এলগরিদম / অ্যালগরিদম।</strong> আর অ্যালগরিদম গুলোর চিত্রিত রুপ হচ্ছে ফ্লো চার্ট বা প্রবাহ চিত্র।</p>
<p>তো কাজ গুলো করতে ধাপ গুলো একের পর এক অনুসরণ করতে হয়। যেমন আমরা স্কুলে যাওয়ার ফ্লো চার্ট তৈরি করলে আগে আমাদের ব্যাগ গুছিয়ে নিতে হবে। এরপর স্কুলের দিকে রওনা দিব। ব্যাগ না গুছিয়ে যদি স্কুলের দিকে যাই, তাহলে তো ঠিক হবে না, তাই না? এ জন্যই কাজ বা কম্পিউটার প্রোগ্রাম লেখার সময়ও ধারাবাহিকতা অনুসরণ করতে হয়। আবার ফ্লো চার্ট তৈরি করার  ও কিছু নিয়ম রয়েছে। নিচের ছবিটি দেখি। এখানে ফ্লো চার্ট তৈরিতে যে চিহ্ন গুলো ব্যবহার করা হয়, যে গুলো দেখা হলো।</p>
<img src="images/flow_chart_symbols.gif" alt="flowchart-symbols"  /> 
<ul>
<li><strong>একঃ</strong> প্রান্তিক প্রতীক [Start / End]: উপবৃত্তাকার চিহ্ন। ফ্লো চার্ট এর শুরু এবং শেষ বোঝাতে এ চিহ্ন ব্যবহৃত হয়।</li>
<li><strong>দুইঃ</strong> তীর [Arrow] চিহ্নঃ একটা ধাপ থেকে আরেকটা ধাপের দিক নির্দেশন দিতে ব্যবহৃত হয়।</li>
<li><strong>তিনঃ</strong> Input / Output চিহ্নঃ প্রোগ্রামে যদি কোন কিছু ব্যবহার কারী থেকে গ্রহন করে বা ব্যবহার কারীকে কিছু প্রদান করে, তার জন্য এ চিহ্ন ব্যবহার করা হয়।</li>
<li><strong>চারঃ</strong> প্রসেসিং বা প্রক্রিয়াকরণ চিহ্নঃ গানিতিক বা লজিক্যাল কোন অপারেশন করতে হলে এই চিহ্ন ব্যবহার করা হয়।</li>
<li><strong>পাঁচঃ</strong> সিন্ধান্ত / Decision চিহ্নঃ কোন সিদ্ধান্ত নিতে হলে এ চিহ্ন ব্যবহৃত হয়। যেমন হ্যাঁ সিন্ধান্ত, না সিদ্ধান্ত ইত্যাদি।</li>
</ul>

<p>উপরের বিষয় গুলো এখনি পরিষ্কার হয়ে যাবে। আমরা একটা ফ্লোচার্ট দেখি। একটা ল্যাম্প জ্বালানোর ফ্লো চার্ট&#8230;</p>

<img class="wp-image-374" src="images/lamp_flowchart.svg.png" /></a>
<ul>
<li>ল্যাম্প যদি কাজ না করে, তাহলে আমরা দেখব ল্যাম্পটি কি বিদ্যুৎ লাইনের সাথে প্লাগ করা আছে কিনা। আর এটা একটা সিন্ধান্ত। আমরা চেক করে দেখব। যদি বিদ্যুৎ লাইনের সাথে প্লাগ করা না থাকে, তাহলে তা প্লাগ করব। আমাদের ল্যাম্পটি জ্বালানোর কাজ শেষ। তাই ফ্লো চার্ট এর শেষ চিহ্ন ব্যবহার করব। প্লাগ করার পর তো আর কোন কাজ করার নেই, তাই।</li>
<li> যদি দেখি বিদ্যুৎ লাইনের সাথে প্লাগ করা আছে ল্যাম্পটি, তাহলে আমরা দেখব ল্যাম্পের বাতিটি কি নষ্ট হয়ে গিয়েছে নাকি ঠিক আছে। এটাও আরেকটা সিদ্ধান্ত মূলক ধাপ। তাই এটাতে সিন্ধান্ত / Decision চিহ্ন ব্যবহার করা হয়েছে।</li>
<li>যদি বাতি নষ্ট হয়ে যায়, তাহলে বাতিটি রিপ্লেস করব। আমাদের কাজ শেষ।</li>
<li> যদি বাতি ঠিক থাকে, তাহলে বুঝতে হবে ল্যাম্পটি নষ্ট। ল্যাম্পটি ঠিক করতে দিব। কাজ শেষ।</li>
</ul>
<p>আচ্ছা&#8230; এখনো যদি বুঝতে অসুবিধে হয়, আমরা আরেকটি উদাহরণ দেখি। এবার আমরা দুইটি সংখ্যা থেকে কোনটা বড় তা বের করার একটা ফ্লোচার্ট তৈরি করব।</p>
<img   src="images/EX-3.png" alt="EX 3"  />

<ul>
<li><strong>প্রথম ধাপঃ</strong> প্রথমে প্রোগ্রামটা শুরুর করতে হবে, এ জন্য শুরু/শেষ চিহ্ন।</li>
<li><strong>দ্বিতীয় ধাপঃ</strong> এরপর যে সংখ্যা দুইটি থেকে বড়টা বের করতে হবে, সে গুলো ইনপুট নিতে হবে। ইনপুট আউটপুটের চিহ্ন ব্যবহার করেছি এখানে আমরা। ধরে নিচ্ছিল একটা সংখা A আরেকটি B.</li>
<li><strong>তৃতীয় ধাপঃ</strong> সিন্ধান্ত নিব।  দেখব A কি B থেকে বড়?</li>
<li><strong>চতুর্থ ধাপঃ</strong> যদি উত্তর হ্যা হয়, তাহলে আমরা আউটপুট দিব, A is maximum. উত্তর যদি না হয়, তাহলে আউটপুট দিব B is maximum.</li>
<li><strong>পঞ্চম ধাপঃ</strong> প্রোগ্রামটি শেষ করব।</li>
</ul>
<p>এবার সহজ মনে হচ্ছে, তাই না? ফ্লো চার্ট সহজই&#8230;</p>
<p>যেমন আমরা আরেকটি ফ্লো চার্ট তৈরি করতে পারি। দুইটি সংখার যোগ ফল বের করার ফ্লো চার্টঃ</p>
<img  src="images/lec14_clip_image016.jpg" />

<ul>
<li><strong>প্রথম ধাপঃ</strong> প্রথমে প্রোগ্রামটা শুরুর করতে হবে, এ জন্য শুরু/শেষ চিহ্ন।</li>
<li><strong>দ্বিতীয় ধাপঃ</strong> এরপর যে সংখ্যা দুইটর যোগ ফল বের  করতে হবে, সে গুলো ইনপুট নিতে হবে। ইনপুট আউটপুটের চিহ্ন ব্যবহার করেছি এখানে আমরা। ধরে নিচ্ছিল একটা সংখা A আরেকটি B। তো আমরা একই ধাপে দুইটি সংখা ইনপুট নিতে পারি। আবার দুইটি ধাপেও পারি। উপরের ফ্লো চার্টে আমরা একই ধাপে নিয়েছি।</li>
<li><strong>তৃতীয় ধাপঃ</strong>  এবার হচ্ছে প্রসেসিং। আমদের যোগ করতে হবে দুইটা সংখা। যোগ করলাম, এ জন্য ব্যবহার করেছি প্রসেসিং চিহ্ন।</li>
<li><strong>চতুর্থ ধাপঃ</strong>  যোগফলটা প্রিন্ট করব। এ জন্য ইনপুট আউটপুট চিহ্ন ব্যবহার করেছি।</li>
<li><strong>পঞ্চম ধাপঃ</strong> প্রোগ্রামটি শেষ করব।</li>
</ul>

<p>আমরা ছোট খাটো সমস্যার ফ্লো চার্ট তৈরি করেছি। এভাবে আমরা যে কোন সমস্যার / কাজের / প্রোগ্রামের ফ্লোচার্ট তৈরি করে ফেলতে পারি। আর ফ্লো চার্ট দেখে দেখে আমরা কম্পিউটার প্রোগ্রাম লিখে পেলতে পারি।</p>

<p>কোন সমস্যার ফ্লো চার্ট তৈরি করে ফেললে প্রোগ্রাম লেখা অনেক সহজ হয়ে যায়। তাই আমরা প্রোগ্রামিং শেখার পাশা পাশি ফ্লোচার্ট সহ অন্যান্য বিষয় গুলো শিখি।</p>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c2578">

	<div data-role="header">	
	
		<h1>C/সি প্রোগ্রামিং এ ডাইনামিক মেমরি এলোকেশন</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>রানটাইমে মেমরি এলোকেট করার প্রসেসকে ডাইনামিক মেমরি এলোকেশন বলে।</p>
<p>আমরা যখন একটা অ্যারে ডিক্লেয়ার করি, তখন কোন কোন সময় অনেক বিশাল একটা অ্যারে ডিক্লেয়ার করি, যার বেশিরভাগই লাগে না। আবার অনেক সময় অনেক ছোট একটা অ্যারে ডিক্লেয়ার করি, কিন্তু প্রোগ্রাম রান করার পর আমাদের আরো বড় সাইজের দরকার হতে পারে। আর এ সমস্যা গুলো সমাধানের জন্যই হচ্ছে ডাইনামিক মেমরি এলোকেশন।</p>
<p>সি প্রোগ্রামিং stdlib.h এ চারটি লাইব্রেরী ফাংশন রয়েছে যে গুলো দিয়ে আমরা ডাইন্যামিকেলি মেমরি এলোকেট করতে পারি। ফাংশন গুলো হচ্ছেঃ</p>
<p>* malloc()<br />
* calloc()<br />
* free()<br />
* realloc()</p>

<p>সবার আগে free ()এর কাজ বলে নি। free নাম থেকেই বুঝা যায় এটা দিয়ে এলোকেটকৃত মেমরি মুক্ত/dellocate করে দেওয়া হয়।</p>
<h3><strong>malloc() ব্যবহারের সিনট্যাক্সঃ</strong></h3>
<p><strong><em>var = malloc(byte-size)</em></strong></p>
<p>যদি আমাদের র‍্যামে মেমরি এলোকেট করার মত মেমরি না থাকে, তাহলে এলোকেশন করতে পারবে না। এবং একটা নাল পয়েন্টার রিটার্ন করবে। যদিও এখনকার কম্পিউটারে এ সমস্যা হওয়ার কথা না… যথেষ্ট র‍্যাম থাকে। একটি উদাহরণঃ</p>
<xmp>

#include <stdio.h>
#include <string.h>;
#include <stdlib.h>;

int main()
{
char *dynamic_var;

dynamic_var = malloc( 200 * sizeof(char) );

if( dynamic_var== NULL )
{
printf("Couldn't able to allocate requested memory\n");
}
else
{
strcpy( dynamic_var,"Dynamically allocated string.");
}
printf("%s\n", dynamic_var );

free(dynamic_var);

return 0;
}

</xmp>
<p>dynamic_var নামে একটি ডাইনামিক ভ্যারিয়েবল নিয়েছি। যার কোন সাইজ আমরা সেট করে দি নাই। আমরা malloc দিয়ে এই dynamic_var এর সাইজ সেট করেছি। if else দিয়ে আমরা dynamic_var চেক করে নিয়েছি। যদি মেমরি এলোকেট করতে না পারে, তাহলে আমাদের লেখা উঠবে &#8220;Couldn&#8217;t able to allocate requested memory&#8221; আর যদি মেমরি এলোকেট করতে পারে, তাহলে strcpy স্ট্রিং ফাংশন ব্যবহার করে dynamic_var এ Dynamically allocated string. এ স্ট্রিংটি এসাইন করবে। এরপর আমরা dynamic_var ভ্যারিয়েবলটি প্রিণ্ট করেছি।</p>
<p>শেষে free ব্যবহার করে এলোকেটকৃত মেমরি মুক্ত করে দিয়েছি।</p>
<p>আরেকটা উদাহরণ দিচ্ছিঃ</p>

<xmp>

#include <stdio.h>
#include <string.h>;
#include <stdlib.h>;

int main()
{
int *dynamic_var;
int n,i;
printf("How many number you will store? ");
scanf("%d",&n);

dynamic_var = malloc( n * sizeof(int) );
if( dynamic_var== NULL )
{
printf("Couldn't able to allocate requested memory\n");
}
else
{
// Read Dynamically Allocated values

for (i=0; i<n;i++){
printf("Enter number %d :", i+1);
scanf("%d",&dynamic_var[i]);
}
}
// Printing Dynamically Allocated values
for (i=0; i<n;i++){
printf("Number %d = %d \n", i+1, dynamic_var[i]);

}

free(dynamic_var);

return 0;
}

</xmp>
<p>এখানে আমরা dynamic_var নামক একটা ইন্টিজার পয়েন্টার ভ্যারিয়েবল নিয়েছি। আমরা dynamic_var এ কয়েকটি নাম্বার স্টোর করতে চাই, তা ইনপুট নিয়েছি n নামক ভ্যারিয়েবল দিয়ে। এরপর এটার সাইজ ডাইনামিক্যালি এলোকেট করেছি, n * sizeof(int) দিয়ে।<br />
এরপরের কাজ সহজ। আমরা ফর লুপ চালিয়ে নাম্বার গুলো ইনপুট নিয়েছি। এরপর সে গুলো আবার আউটপুট দিয়েছি।</p>
<h3><strong>calloc()</strong></h3>
<p>calloc() এবং malloc() এর সিনট্যাক্সে তেমন কোন পার্থক্য নেই। দুটাই একই ভাবেই ব্যবহার করা হয়। calloc() করে কি, প্রথমে ০ দিয়ে ইনিশিয়ালাইজ করে নেয়। পরে মেমরিতে পয়েন্টার রিটার্ন করে। একই উদাহরন calloc() দিয়ে লিখলেঃ</p>
<xmp>

#include <stdio.h>
#include <string.h>;
#include <stdlib.h>;

int main()
{
char *dynamic_var;

dynamic_var =calloc( 200 , sizeof(char) );

if( dynamic_var== NULL )
{
printf("Couldn't able to allocate requested memory\n");
}
else
{
strcpy( dynamic_var,"Dynamically allocated string.");
}
printf("%s\n", dynamic_var );

free(dynamic_var);

return 0;
}

</xmp>
<h3><strong>realloc()</strong></h3>
<p>calloc() এবং malloc() দিয়ে এলোকেট করা মেমরি যদি ইনসাফিশিয়েন্ট হয়, তাহলে realloc() দিয়ে প্রয়োজন অনুযায়ী আবার মেমরি এলোকেট করে নেওয়া যায়। উদারহণঃ</p>
<xmp>

#include <stdio.h>
#include <string.h>;
#include <stdlib.h>;

int main()
{
char *dynamic_var;
//allocate
dynamic_var = malloc( 100 * sizeof(char) );

if( dynamic_var== NULL )
{
printf("Couldn't able to allocate requested memory\n");
}
else
{
strcpy( dynamic_var,"Dynamically allocated string.");
}
printf("%s\n", dynamic_var );

//reallocate
dynamic_var = realloc( dynamic_var, 200 * sizeof(char) );

if( dynamic_var== NULL )
{
printf("Couldn't able to allocate requested memory\n ");
}
else
{
strcat( dynamic_var,"With more reallocated content");
}
printf("%s\n", dynamic_var );

free(dynamic_var);

return 0;
}

</xmp>
<p>উপরের প্রোগ্রামের প্রথম অংশ malloc() এর প্রথম উদারহণটির মতই। এর পরবর্তিতে আমাদের আরো কিছু যোগ করা দরকার, তাই আমরা realloc() ব্যবহার করে মেমরি বাড়িয়ে নিলাম।আরেকটা উদাহরণঃ</p>
<xmp>

#include <stdio.h>
#include <stdlib.h>;
int main(){
int *dynamic_var ,i,n1,n2;
printf("Enter size of array: ");
scanf("%d",&n1);

dynamic_var =(int*)malloc(n1*sizeof(int));

printf("Address of previously allocated memory: ");

for(i=0;i<n1;++i)
printf("%u\t",dynamic_var +i);

printf("\nEnter new size of array: ");
scanf("%d",&n2);

dynamic_var =realloc(dynamic_var ,n2);

for(i=0;i<n2;++i)
printf("%u\t",dynamic_var +i);
return 0;
}

</xmp>
<p>এখানে প্রথমে জিজ্ঞেস করবে কত সাইজে অ্যারে দরকার। পরে তত সাইজের একটি অ্যারে তৈরি করবে। এবং ঐ অ্যারের এড্রেস গুলো প্রিন্ট করবে। আমরা চাইলে ঐ অ্যারেতে ইনপুট নিয়ে রাখতে পারি। প্রিন্ট করতে পারি।</p>
<p>এরপর আবার জিজ্ঞেস করবে নিউ অ্যারে সাইজ। এখন যদি আগের থেকে বড় কোন মান দিয়ে থাকি, তাহলে আগের থেকে বড় একটা অ্যারে আমাদের জন্য তৈরি করবে। ছোট ভ্যালু দিলে আগের অ্যারেটা ছোট করে দিবে।এবং অ্যারের এড্রেস গুলো প্রিন্ট করবে। যেমন প্রথম বার ৫ ইনপুট করে দেখুন। এরপরে ২ বা ৮ ইনপুট করে দেখতে পারেন।</p>

<ul>
 
</ul>
 


	
	</div>
</div><!-- /page -->

  
<div data-role="page" id="c2594">

	<div data-role="header">	
	
		<h1>লিঙ্কড লিস্ট / Linked list সম্পর্কে ধারণা এবং সি প্রোগ্রামিং এ ইমপ্লিমেন্টেশন</h1>
	</div>

	<div role="main" class="ui-content">

	 
 <p>ডেটা স্টোর করার জন্য অ্যারের মত আরেকটি ডেটা স্ট্যাকচার হচ্ছে Linked List। এটি স্ট্র্যাকচার অনুযায়ী ডাটা স্টোর করে, এবং রান টাইমে নতুন স্পেসের দরকার হলে অটোমেটিকেলি তা তৈরি করে নিতে পারে।  এটি হচ্ছে ডাইনামিক ডেটা স্ট্রাকচার।</p>
<p>এটি অ্যারের মতই, তবে অ্যারেতে আমাদের কতটুকু মেমরি দরকার, প্রথমেই বলে দিতে হয়। কিন্তু লিঙ্কড লিস্টে প্রয়োজন অনুযায়ী মেমরি বাড়ানো বা কমিয়ে নেওয়া যায়। আরো দুইটা সুবিধে হচ্ছে, লিঙ্কড লিস্টের মাঝখান থেকে এর যে কোন আইটেম রিমুভ করা যায় বা মাঝখানে নতুন আইটেম যুক্ত করা যায়। আর ইনিশালি কোন সাইজ ডিক্লেয়ার করে দিতে হয় না।</p>
<p>অসুবিধেও রয়েছে। অ্যারে রেন্ডম এক্সেস করা যায়, কিন্তু লিঙ্কড লিস্টে রেডম এক্সেস করা যায় না।</p>
<p>লিঙ্কড লিস্ট হচ্ছে ডাইন্যামিক্যালই এলোকেটেড নোড। প্রত্যেকটা নোডের একটা ভ্যালু এবং একটা পয়েন্টার থাকে। পয়েন্টার এর পরবর্তি নোড বা লিঙ্কড লিস্টের পরবর্তি মেম্বারকে পয়েন্ট করে। এটা ট্রেনের মত। প্রথম মেম্বার হচ্ছে ট্রেনের ইঞ্জিন। এবং এরপরবর্তী  বগিটি ইঞ্জিনের সাথে কানেকটেড থাকে, যা পয়েন্টার। পরের বগিটি এর পরের বগিটির সাথে কানেকটেড থাকে। যদি শেষে কোন বগি না থাকে, তখন আমরা বলি ট্রেনের শেষ। একই ভাবে লিঙ্কড লিস্টের পয়েন্টার যদি শূন্য হয়, তাহলে আমরা বলি এর পর আর কোন মেম্বার নেই। লিঙ্কড লিস্টে প্রথম নোড অনেক গুরুত্বপূর্ন, কারণ এটাতে পরবর্তী মেম্বারের পয়েন্টার থাকে। যদি প্রথম মেম্বার কোন ক্রমে রিমুভ হয়ে যায়, তাহলে পুরো লিঙ্কড লিস্টিই আর খুঁজে পাওয়া যাবে না। ট্রেনের ইঞ্জিন ছাড়া অন্য বগি গুলো যেমন কোন কাজে আসে না।</p>
<p>নিচের ছবিটি দেখিঃ<br />
<a href="images/node.jpg" rel="lightbox[2594]" title="node"><img class="aligncenter size-full wp-image-2595" src="images/node.jpg" alt="node" width="222" height="87" /></a><br />
এটি হচ্ছে লিঙ্কড লিস্টের একটি নোড। নোডের দুইটা অংশ, একটা হচ্ছে ডেটা। আরেকটা হচ্ছে এড্রেস। এমন অনেক গুলো নোড নিয়েই লিঙ্কড লিস্ট তৈরি।  প্রথম নোডের Address দ্বিতীয় নোডের এড্রেস পয়েন্ট করা থাকে। নিচের ছবিটির মতঃ</p>
<div id="cattachment_2596" style="width: 418px" class="wp-caption aligncenter"><a href="images/408px-Singly-linked-list.svg_.png" rel="lightbox[2594]" title="408px-Singly-linked-list.svg"><img class="wp-image-2596 size-full" src="images/408px-Singly-linked-list.svg_.png" alt="408px-Singly-linked-list.svg" width="408" height="41" srcset="images/408px-Singly-linked-list.svg_-300x30.png 300w, images/408px-Singly-linked-list.svg_.png 408w" sizes="(max-width: 408px) 100vw, 408px" /></a><p class="wp-caption-text">ইমেজ সোর্সঃ http://en.wikipedia.org/wiki/Linked_list</p></div>

<p>এভাবে যত ইচ্ছে তত গুলো নোড যুক্ত করা যায়।</p>
<p>ট্রেনের এক একটা আলাদা ব্লককে আমরা বলি বগি, লিঙ্কড লিস্টে আমরা বলব নোড।</p>
<p>লিঙ্কড লিস্ট ইমপ্লিমেন্টেশনের জন্য পয়েন্টার ব্যবহার করা হয়, তাই লিঙ্কড লিস্ট সম্পর্কে জানার পূর্বে পয়েন্টার সম্পর্কে জানা দরকার। আরো দুইটা টপিক্স গুরুত্ব পূর্ণ, তা হচ্ছে ডাইনামিক মেমরি এলোকেশন এবং স্ট্যাকচার।</p>
 
<p>সি  প্রোগ্রামিং ইমপ্লিমেন্ট করার জন্য নোডের একটা স্ট্র্যাকচার তৈরি করে নিব এভাবেঃ</p>
<xmp>

typedef struct nodes {
int val;
struct nodes * next;
} node;

</xmp>
<p>আমরা এবার আমাদের লিঙ্কড লিস্টে প্রথম নোড যুক্ত করবঃ</p>
<xmp>

node * curr, * head;
head = NULL;

curr = (node *)malloc(sizeof(node));
curr->;val = 10;
curr->;next  = head;
head = curr;

</xmp>
<p>এখানে একটা হচ্ছে current নোড, আরেকটা হচ্ছে head. প্রথমে   head = NULL এর মানে আমাদের লিস্টে কিছুই নেই।</p>
<p>এরপর আমরা একটা নোড যুক্ত করেছি। তা হচ্ছে current নোড। যার ভ্যালু হচ্ছে 10. এরপর কারেন্ট নোডের নেক্সট ভ্যালু সেট করে দিয়েছি head, মানে নাল পয়েন্টার। শেষে head এ আমাদের কারেন্ট নোড এসাইন করে দিয়েছি। যেহেতুই আমাদের লিস্টে একটাই ভ্যালু, আমরা সিমপ্লি তা প্রিন্ট করতে পারিঃ</p>
<xmp>

printf("%d\n", curr->;val);

</xmp>
<p>এখন যদি আমরা আরেকটা ভ্যালু যুক্ত করতে চাই, তাহলে লিখবঃ</p>
<xmp>

curr = (node *)malloc(sizeof(node));
curr->;val = 20;
curr->;next  = head;
head = curr;

</xmp>
<p>এখন যেহেতু দুইটা ভ্যালু, আমরা আগের মত প্রিন্ট করতে পারব না। আমাদের লুপ চালাতে হবে, তার জন্যঃ</p>
<xmp>

while(curr) {
printf("%d\n", curr->;val);
curr = curr->;next ;
}

</xmp>
<p>এবং সম্পুর্ণ প্রোগ্রামঃ</p>
<xmp>

#include <stdio.h>
#include<stdlib.h>;
int main() {
typedef struct nodes {
int val;
struct nodes * next;
} node;

node * curr, * head;
head = NULL;

curr = (node *)malloc(sizeof(node));
curr->;val = 10;
curr->;next  = head;
head = curr;

curr = (node *)malloc(sizeof(node));
curr->;val = 20;
curr->;next  = head;
head = curr;

curr = head;

while(curr) {
printf("%d\n", curr->;val);
curr = curr->;next ;
}

return 0;
}

</xmp>
<p>যেখানে আমরা দুইটা নোড যুক্ত করেছি। এবং শেষে নাল পয়েন্টারে পয়েন্ট করে দিয়েছি, মানে আমাদের যুক্ত করা শেষ। আরেকটা সিম্পল প্রোগ্রাম লিখিঃ</p>
<xmp>

#include<stdlib.h>;
#include<stdio.h>

typedef struct nodes {
int val;
struct nodes * next;
} node;

void main() {
node * curr, * head;
int i;

head = NULL;

for(i=1;i<=10;i++) {
curr = (node *)malloc(sizeof(node));
curr->;val = i;
curr->;next  = head;
head = curr;
}

curr = head;

while(curr) {
printf("%d\n", curr->;val);
curr = curr->;next ;
}
return 0;
}

</xmp>
<p>এখানে i নামে একটা ভ্যারিয়েবল নিয়েছি। ফর লুপ দিয়ে i এর মান এক এক করে বাড়িয়ে তা লিঙ্কড লিস্টে রেখেছি। পরে while লুপ দিয়ে আমরা লিঙ্কড লিস্টটি প্রিন্ট করেছি।</p>
<p>উপরে আমরা যে লিঙ্কডলিস্টটি দেখেছি, তাকে বলে <b>Singly linked lists</b>, এটার প্রথম নোডের সাথে পরের নোডের এড্রেস যুক্ত থাকে, এরপরের টার সাথে থাকে এর পরের নোডের এড্রেস। এভাবে শেষ পর্যন্ত।</p>
<h3><b>Doubly linked list:</b></h3>
<p>আরেক টাইপের লিঙ্কড লিস্ট রয়েছে, তা হচ্ছে <b>Doubly linked list</b>, যেখানে এড্রেসের জন্য থাকে দুইটা খোপ। যেমন previous address, next address নামক দুইটা এড্রেস ফিল্ড। এখানে প্রথম নোডের  previous address এ থাকে একটা নাল ভ্যালু। কারণ প্রথম নোডের পূর্বে আর কোন নোড নেই। দ্বিতীয় নোডের  previous address এ থাকে প্রথম নোডের এড্রেস। এবং next address  এ থাকে তৃতীয় নোডের এড্রেস। এভাবে শেষ নোডের next address  এ থাকে একটা নাল ভ্যালু। Doubly linked list দেখতে নিচের মতঃ</p>

<img class="size-full wp-image-2597" src="images/610px-Doubly-linked-list.svg_.png"/>
<p>আমরা পূর্বের প্রোগ্রামে একটু পরিবর্তন করলেই <b>Doubly linked list</b> টা ইমপ্লিমেন্ট করতে পারি। যেমন আমরা আমাদের স্ট্র্যাকচয়ারে prev নামক আরেকটা ফিল্ড তৈরি করে নি।</p>
<xmp>

typedef struct nodes {
int val;
struct nodes * next;
struct nodes * prev;
} node;

</xmp>
<p>তাহলে এবার এ স্ট্র্যাকচারটি ব্যবহার করে আমরা  <b>Doubly linked list </b> তৈরি করে ফেলতে পারি। নিজে একটু চেষ্টা করে দেখতে পারেন। অনলাইনে অনেক গুলো কোড পাওয়া যাবে, না পারলে গুগল থেকে চার্চ করে দেখে নিতে পারেন। 
</p>
<h3><b>Circularly linked list:</b></h3>
<p>Singly linked lists এর শেষ নোডের পরে আর কোন নোড না থাকায় আমরা নেক্সট এড্রেসে একটা নাল ভ্যালু সেট করে দি। কিন্তু নাল ভ্যালু সেট না করে আমরা যদি সেখানে প্রথম নোডের এড্রেস সেট করি, তাহয়ে যাবে একটা  Circularly linked list। নিচের ছবিটি দেখি।</p>
 
<img class="size-full wp-image-2598" src="images/Circularly-linked-list.svg_.png"/>

<p>আমরা চাইলে উপরের কোডে সামান্য একটু পরিবর্তন করেই Circularly linked list  ইমপ্লিমেন্ট করতে পারি।</p>
<h3><b>Doubly linked Circular list: </b></h3>
<p>নাম দেখেই বোঝা যাচ্ছে  যে এটা Doubly linked list এর মত। শেষ নোডের next address  প্রথম নোডে এবং প্রথম নোডের  previous address এ শেষ নোডের এড্রেস সেট করে দিলে তা হয়ে যায় Doubly<b> </b>linked Circular list , নিচের ছবির মতঃ</p>
<p><img src="images/dbl-lnk2.gif" alt="" /><a href="images/dbl-lnk2.gif" rel="lightbox[2594]" title="dbl-lnk2"><img class="aligncenter size-full wp-image-2599" src="images/dbl-lnk2.gif" alt="dbl-lnk2" width="494" height="189" /></a></p>
<p>একটু চেষ্টা করলে ইমপ্লিমেন্টেশন করা যাবে। আর না পারলে গুগলের সাহায্য নিতে পারেন। </p>
 


	
	</div>
</div><!-- /page -->





  





<div data-role="page" id="empty">

	<div data-role="header">
	
	
	
		
	</div>

	<div role="main" class="ui-content">

	 
 


	
	</div>
</div><!-- /page -->
 

 


</body>
</html>